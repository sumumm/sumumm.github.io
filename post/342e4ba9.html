<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/green/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"sumumm.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":300},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文主要是C语言基础——内存管理简介相关笔记，若笔记中有错误或者不合适的地方，欢迎批评指正😃。">
<meta property="og:type" content="article">
<meta property="og:title" content="LV01-16-C语言-内存管理">
<meta property="og:url" content="https://sumumm.github.io/post/342e4ba9.html">
<meta property="og:site_name" content="苏木">
<meta property="og:description" content="本文主要是C语言基础——内存管理简介相关笔记，若笔记中有错误或者不合适的地方，欢迎批评指正😃。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220419100225475.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220419102607390.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220918090740953.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220918091147368.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220918091532043.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220918094201817.png">
<meta property="article:published_time" content="2022-03-05T09:43:05.000Z">
<meta property="article:modified_time" content="2025-06-13T16:25:56.986Z">
<meta property="article:author" content="苏木">
<meta property="article:tag" content="LV01-C语言基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220419100225475.png">


<link rel="canonical" href="https://sumumm.github.io/post/342e4ba9.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sumumm.github.io/post/342e4ba9.html","path":"post/342e4ba9.html","title":"LV01-16-C语言-内存管理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LV01-16-C语言-内存管理 | 苏木</title>
  








    <script src="/js/browser_tools_disable.js"></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.com/hexo-next-tags-plus@latest/lib/tag_plus.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">苏木</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我的学习之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>苏木的家</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类页<span class="badge">42</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档页<span class="badge">673</span></a></li><li class="menu-item menu-item-flink"><a href="/flink/" rel="section"><i class="fa fa-link fa-fw"></i>友人帐</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-text">一、内存空间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="nav-text">1.代码区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="nav-text">2.静态存储区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%A0%88%E5%8C%BA"><span class="nav-text">3.栈区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%A0%86%E5%8C%BA"><span class="nav-text">4.堆区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">5.堆与栈的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F"><span class="nav-text">5.1申请方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E7%94%B3%E8%AF%B7%E5%90%8E%E7%B3%BB%E7%BB%9F%E5%93%8D%E5%BA%94"><span class="nav-text">5.2申请后系统响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E9%80%9F%E5%BA%A6%E9%99%90%E5%88%B6"><span class="nav-text">5.3速度限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6"><span class="nav-text">5.4大小限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5%E5%A0%86%E5%92%8C%E6%A0%88%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9"><span class="nav-text">5.5堆和栈中的存储内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E8%BF%99%E4%B9%88%E5%A4%9A%E9%83%A8%E5%88%86%EF%BC%9F"><span class="nav-text">6. 为什么要分这么多部分？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">二、动态内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-text">1.堆内存的分配与释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E5%87%BD%E6%95%B0"><span class="nav-text">2.内存申请函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-malloc"><span class="nav-text">2.1 malloc() </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-calloc"><span class="nav-text">2.2 calloc() </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-realloc"><span class="nav-text">2.3 realloc() </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E5%87%BD%E6%95%B0"><span class="nav-text">3.内存释放函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-free"><span class="nav-text">3.1 free() </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AE%9E%E4%BE%8B"><span class="nav-text">3.内存分配实例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">三、内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-32-%E4%BD%8D-Linux"><span class="nav-text">1. 32 位 Linux </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-64-%E4%BD%8D-Linux"><span class="nav-text">2. 64 位 Linux </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%B8%80%E4%B8%AA%E6%98%93%E9%94%99%E7%82%B9"><span class="nav-text">四、一个易错点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%A3%E7%A0%81%E4%B8%8E%E7%8E%B0%E8%B1%A1"><span class="nav-text">1.代码与现象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90"><span class="nav-text">2.错误分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-get-memory-%E8%B0%83%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-text">2.1 get_memory() 调用情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%89%8D"><span class="nav-text">2.2分配内存前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%90%8E"><span class="nav-text">2.3分配内存后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-get-memory-%E8%B0%83%E7%94%A8%E7%BB%93%E6%9D%9F"><span class="nav-text">2.4 get_memory() 调用结束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%A8%8B%E5%BA%8F%E4%BF%AE%E6%94%B9"><span class="nav-text">3.程序修改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E6%96%B9%E5%BC%8F1"><span class="nav-text">3.1方式1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E6%96%B9%E5%BC%8F2"><span class="nav-text">3.2方式2</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苏木"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">苏木</p>
  <div class="site-description" itemprop="description">莫道桑榆晚，为霞尚满天</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">673</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sumumm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sumumm" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sumumm.github.io/post/342e4ba9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="苏木">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏木">
      <meta itemprop="description" content="莫道桑榆晚，为霞尚满天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LV01-16-C语言-内存管理 | 苏木">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LV01-16-C语言-内存管理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-05 17:43:05" itemprop="dateCreated datePublished" datetime="2022-03-05T17:43:05+08:00">2022-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">嵌入式开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/" itemprop="url" rel="index"><span itemprop="name">01HQ课程体系</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">LV01-C语言基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文主要是C语言基础——内存管理简介相关笔记，若笔记中有错误或者不合适的地方，欢迎批评指正😃。</p>
<span id="more"></span>

<!-- Photo: https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/ -->

<details class="folding-tag" blue><summary> 点击查看使用工具及版本 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center" width=150px>Windows</td>        <td align="left">windows11</td>    </tr>    <tr>        <td align="center">Ubuntu</td>        <td align="left">Ubuntu16.04的64位版本</td>      </tr>    <tr>        <td align="center">VMware® Workstation 16 Pro</td>        <td align="left">16.2.3 build-19376536</td>      </tr>    <tr>        <td align="center">SecureCRT</td>        <td align="left">Version 8.7.2 (x64 build 2214)   -   正式版-2020年5月14日</td>      </tr>    <tr>        <td align="center">开发板</td>        <td align="left">正点原子 i.MX6ULL Linux阿尔法开发板</td>      </tr>    <tr>        <td align="center">uboot</td>        <td align="left">NXP官方提供的uboot，NXP提供的版本为uboot-imx-rel_imx_4.1.15_2.1.0_ga(使用的uboot版本为U-Boot 2016.03)</td>      </tr>    <tr>        <td align="center">linux内核</td>        <td align="left">linux-4.15(NXP官方提供)</td>      </tr>    <tr>        <td align="center">STM32开发板</td>        <td align="left">正点原子战舰V3(STM32F103ZET6)</td>      </tr></table>
              </div>
            </details>

<details class="folding-tag" blue><summary> 点击查看本文参考资料 </summary>
              <div class='content'>
              <table>    <tr><td align="center">参考方向  </td><td align="center">参考原文</td></tr>    <tr><td align="left"> 动态内存申请 </td><td align="left"><a href="https://blog.csdn.net/weixin_38645650/article/details/124706330" target="_blank"> 关于C语言动态内存开辟的小题_三余-无梦的博客-CSDN博客 <i class="fa fa-external-link-alt"></i> </a></td></tr></table>
              </div>
            </details>

<details class="folding-tag" blue><summary> 点击查看相关文件下载 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center">---</td>        <td align="left">--- <a href="" target="_blank">  <i class="fa fa-external-link-alt"></i></a></td>      </tr></table>
              </div>
            </details>

<p>内存的使用是程序设计中需要考虑的重要因素之一，这不仅由于系统内存是有限的（尤其在嵌入式系统中），而且内存分配也会直接影响到程序的效率。</p>
<h1 id="一、内存空间"><a href="#一、内存空间" class="headerlink" title="一、内存空间"></a><font size=3>一、内存空间</font></h1><p>在 C 语言中，定义四个内存区间：代码区、静态存储区、局部变量区（即栈区）和动态存储区（即堆区）。</p>
<h2 id="1-代码区"><a href="#1-代码区" class="headerlink" title="1.代码区"></a><font size=3>1.代码区</font></h2><p>程序被操作系统加载到内存的时候，所有的可执行代码（程序代码指令、常量字符串等）都加载到代码区，这块内存在程序运行期间是不变的。</p>
<p>在程序运行期间代码区是不能改变的（属性是只读的）。函数也是代码的一部分，故函数都被放在代码区，包括 main 函数。</p>
<p>【说明】 int a &#x3D; 0; 语句可拆分成 int a; 和 a &#x3D; 0 ，定义变量 a 的 int a; 语句并不是代码，它在程序编译时就执行了，并没有放到代码区，放到代码区的只有 a &#x3D; 0 这句。</p>
<h2 id="2-静态存储区"><a href="#2-静态存储区" class="headerlink" title="2.静态存储区"></a><font size=3>2.静态存储区</font></h2><p>静态存储区存放的是全局变量与静态变量（ static 修饰），也可以叫做全局变量与静态变量区。</p>
<p>存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如：全局变量、静态变量和字符串常量。</p>
<p>分配在这个区域中的变量，当程序结束时，才释放内存。因此，经常利用这样的变量，在函数间传递信息。 </p>
<h2 id="3-栈区"><a href="#3-栈区" class="headerlink" title="3.栈区"></a><font size=3>3.栈区</font></h2><p>栈区，也就是局部变量区。栈（ stack ）是一种<strong>先进后出</strong>的内存结构，所有的自动变量、函数形参都存储在栈中，这个动作由编译器自动完成，我们写程序时不需要考虑。</p>
<p>栈区在程序运行期间是可以随时修改的。当一个自动变量超出其作用域时，会自动从栈中弹出。</p>
<p>在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>在 linux 中，可以通过命令 ulimit -s 来查看栈的大小，执行完命令后，在终端会显示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8192</span><br></pre></td></tr></table></figure>

<p>这说明我执行这条命令的系统中栈的容量为 8192kbytes ，也就是 8MB 。</p>
<p><strong>【注意】</strong></p>
<p>（1）<strong>不能将一个栈变量的地址通过函数的返回值返回</strong>。</p>
<p>（2）这种内存方式，变量内存的分配和释放都是自动进行，我们编写代码的时候不需要考虑内存管理的问题，很方便，但是栈的容量有限，且相应的范围结束时，局部变量就不能再使用。</p>
<h2 id="4-堆区"><a href="#4-堆区" class="headerlink" title="4.堆区"></a><font size=3>4.堆区</font></h2><p>堆区，也就是动态存储区。堆（ heap ）和栈一样，也是一种在程序运行过程中可以随时修改的内存区域。</p>
<p>有的操作对象只有在程序运行时才能确定，这样在编译器进行编译的时候就无法为他们预先分配空间，只能在程序运行时进行分配，所以称为动态分配内存。</p>
<p>而所有动态存储分配都在堆区中进行的。所以从堆上分配，亦称动态内存分配。l程序在运行的时候用 malloc 申请任意多少的内存，我们自己负责在何时用 free 释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>
<h2 id="5-堆与栈的区别"><a href="#5-堆与栈的区别" class="headerlink" title="5.堆与栈的区别"></a><font size=3>5.堆与栈的区别</font></h2><h3 id="5-1申请方式"><a href="#5-1申请方式" class="headerlink" title="5.1申请方式"></a><font size=3>5.1申请方式</font></h3><p>栈（ stack ）是由系统自动分配的。例如我们声明了一个局部变量 int b; 那么系统会自动在栈区为 b 开辟空间。</p>
<p>堆（ heap ）需要我们自己去申请，并在申请时指定大小。</p>
<h3 id="5-2申请后系统响应"><a href="#5-2申请后系统响应" class="headerlink" title="5.2申请后系统响应"></a><font size=3>5.2申请后系统响应</font></h3><p>堆在操作系统中有一个记录空闲内存地址的链表。当系统收到程序的申请时，系统就会开始遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小。这样，代码中的删除语句才能正确地释放本内存空间。如果找到的堆节点的大小与申请的大小不相同，系统会自动地将多余的那部分重新放入空闲链表中。</p>
<p>只有栈的剩余空间大于所申请空间，系统才为程序提供内存，否则将报异常，提示栈溢出。</p>
<h3 id="5-3速度限制"><a href="#5-3速度限制" class="headerlink" title="5.3速度限制"></a><font size=3>5.3速度限制</font></h3><p>堆是由 malloc 等函数分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来很方便。</p>
<p>栈由系统自动分配，速度较快，但我们一般无法控制。</p>
<h3 id="5-4大小限制"><a href="#5-4大小限制" class="headerlink" title="5.4大小限制"></a><font size=3>5.4大小限制</font></h3><p>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统用链表来存储的空闲内存地址，地址是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存，因此堆获得的空间比较灵活，也比较大。<br>栈是向低地址扩展的数据结构，是一块连续的内存区域。因此，栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将提示栈溢出，因此，能从栈获得的空间较小。</p>
<h3 id="5-5堆和栈中的存储内容"><a href="#5-5堆和栈中的存储内容" class="headerlink" title="5.5堆和栈中的存储内容"></a><font size=3>5.5堆和栈中的存储内容</font></h3><p>堆一般在堆的头部用一个字节存放堆的大小，堆中的具体内容由我们自己安排。</p>
<p>在调用函数时，第一个进栈的是函数调用语句的下一条可执行语句的地址，然后是函数的各个参数，在大多数的 C 语言编译器中，参数是由右往左入栈的，然后是函数中的局部变量。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始的存储地址，也就是调用该函数处的下一条指令，程序由该点继续运行。</p>
<h2 id="6-为什么要分这么多部分？"><a href="#6-为什么要分这么多部分？" class="headerlink" title="6. 为什么要分这么多部分？"></a><font size=3>6. 为什么要分这么多部分？</font></h2><p>其实我们知道，C语言程序经过编译链接后形成的二进制映像文件由<strong>栈，堆，数据段</strong>（由三部分部分组成：只读数据段，已经初始化读写数据段，未初始化数据段即BBS）和<strong>代码段</strong>组成。前面已经说明了：</p>
<p>栈区(stack)：又叫堆栈，先进先出，由编译器自动分配释放，存放函数的参数值，局部变量等值。其操作方式类似于数据结构中的栈。</p>
<p>堆区(heap)：一般由程序员分配释放，若程序员不释放，则可能会引起内存泄漏。堆和数据结构中的堆栈不一样，其类是与链表。</p>
<p>程序代码区：存放函数体的二进制代码。</p>
<p>数据段：由三部分组成</p>
<p>（1）只读数据段：</p>
<p>只读数据段是程序使用的一些不会被更改的数据，使用这些数据的方式类似查表式的操作，由于这些变量不需要更改，因此只需要放置在只读存储器中即可。一般是const修饰的变量以及程序中使用的文字常量一般会存放在只读数据段中。</p>
<p>（2）已初始化的读写数据段：</p>
<p>已初始化数据是在程序中声明，并且具有初值的变量，这些变量需要占用存储器的空间，在程序执行时它们需要位于可读写的内存区域内，并且有初值，以供程序运行时读写。在程序中一般为已经初始化的全局变量，已经初始化的静态局部变量(static修饰的已经初始化的变量)</p>
<p>（3）未初始化段（BSS）：</p>
<p>未初始化数据是在程序中声明，但是没有初始化的变量，这些变量在程序运行之前不需要占用存储器的空间。与读写数据段类似，它也属于静态数据区。但是该段中数据没有经过初始化。未初始化数据段只有在运行的初始化阶段才会产生，因此它的大小不会影响目标文件的大小。在程序中一般是没有初始化的全局变量和没有初始化的静态局部变量。</p>
<p>那么，代码和数据为什么是分开存放的？是因为程序在内存中是以二进制的形式存放，若是不加以区分，直接按顺序存放，计算机无法区分哪些是指令哪些是数据，除非用一些额外内存加以区分，但是这样会更加的浪费空间，而且有些数据我们使用完可能就丢掉了，将两者混合在一起，会带来巨大的隐患。这段话是从网上看到的，记在这里做笔记，但是总觉得怪怪的，可能还是有些不明确把，后边随时补充。</p>
<h1 id="二、动态内存分配"><a href="#二、动态内存分配" class="headerlink" title="二、动态内存分配"></a><font size=3>二、动态内存分配</font></h1><h2 id="1-堆内存的分配与释放"><a href="#1-堆内存的分配与释放" class="headerlink" title="1.堆内存的分配与释放"></a><font size=3>1.堆内存的分配与释放</font></h2><p>当程序运行到需要一个动态分配的变量或对象时，必须向系统申请取得堆中的一块所需大小的存储空间，用于存储该变量或对象。</p>
<p>当不再使用该变量或对象时，也就是它的生命结束时，要<strong>显式释放它所占用的存储空间</strong>，这样系统就能对该堆空间进行再次分配，做到重复使用有限的资源。</p>
<p><strong>【注意】</strong>堆区是不会自动在分配时做初始化的（包括清零），所以必须用初始化式( initializer )来显式初始化。</p>
<h2 id="2-内存申请函数"><a href="#2-内存申请函数" class="headerlink" title="2.内存申请函数"></a><font size=3>2.内存申请函数</font></h2><h3 id="2-1-malloc"><a href="#2-1-malloc" class="headerlink" title="2.1 malloc() "></a><font size=3>2.1 malloc() </font></h3><p> C  语言中使用 malloc 函数来申请内存，在 linux 中可以使用 man 3 malloc 命令查看该函数的手册，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;;</span><br></pre></td></tr></table></figure>

<p><strong>【函数说明】</strong>动态申请 size 字节的内存空间。函数是如何完成分配的？可以看这篇笔记：《LV05-01-操作系统-内存管理》</p>
<p><strong>【函数参数】</strong></p>
<ul>
<li>size ： size_t 类型，表示需要动态申请的内存的字节数。</li>
</ul>
<p><strong>【返回值】</strong> void * 类型，若内存申请成功，函数返回申请到的内存的起始地址；若申请失败，则返回 NULL 。</p>
<p><strong>【注意】</strong></p>
<p>（1）该函数只关注申请内存的大小，单位是字节。</p>
<p>（2）该函数申请到的内存区域是连续的，申请到的内存可能会比实际申请的大。也有可能会申请不到，所以一定要写一个申请是否成功的判断。</p>
<p>（3）返回值是 void * 类型，不是某种具体类型的指针，也就是说，这个函数只负责申请内存，对在内存中存储什么类型的数据没有任何要求。所以一般使用的时候，需要根据实际情况将 void * 强制转换成所需要的指针类型。</p>
<p>（4）堆区不会自动在分配时做初始化（包括清零），也就是说内存空间在函数执行完成后不会被初始化，它们的值是未知的，所以<strong>程序中一定要做显式的初始化</strong>。</p>
<h3 id="2-2-calloc"><a href="#2-2-calloc" class="headerlink" title="2.2 calloc() "></a><font size=3>2.2 calloc() </font></h3><p> C  语言中的 calloc 函数也可以用于申请内存，在 linux 中可以使用 man 3 calloc 命令查看该函数的手册，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>【函数说明】</strong>在内存中动态地分配  nmemb 个长度为  size  的<strong>连续空间</strong>，并将每一个字节都初始化为  0 。</p>
<p><strong>【函数参数】</strong></p>
<ul>
<li>nmemb ： size_t 类型，表示需要申请多少个内存空间。</li>
<li>size ： size_t 类型，表示申请的内存空间的长度。</li>
</ul>
<p><strong>【返回值】</strong> void * 类型，分配成功返回指向该内存的地址，失败则返回  NULL 。</p>
<p><strong>【注意】</strong></p>
<p>（1） calloc  与  malloc 的一个重要区别是： calloc  在动态分配完内存后，<strong>自动初始化该内存空间为零</strong>，而  malloc  不初始化，里边数据是未知的垃圾数据。下面的两种写法是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1.calloc() 分配内存空间并初始化 */</span></span><br><span class="line"><span class="type">char</span> *str1 = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2. malloc() 分配内存空间并用 memset() 初始化 */</span></span><br><span class="line"><span class="type">char</span> *str2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">memset</span>(str2, <span class="number">0</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>（2）同样是使用 free 函数来释放申请的内存。</p>
<h3 id="2-3-realloc"><a href="#2-3-realloc" class="headerlink" title="2.3 realloc() "></a><font size=3>2.3 realloc() </font></h3><p> C  语言中的 realloc 函数用于重新分配内存空间，在 linux 中可以使用 man realloc 命令查看该函数的手册，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>【函数说明】</strong>尝试重新调整之前调用  malloc  或  calloc  所分配的  ptr  所指向的内存块的大小。</p>
<p><strong>【函数参数】</strong></p>
<ul>
<li>ptr ： void * 类型，表示需要重新分配的内存空间指针。</li>
<li>size ： size_t 类型，表示新的内存空间的大小。</li>
</ul>
<p><strong>【返回值】</strong> void * 类型，分配成功返回新的内存地址，可能与  ptr  相同，也可能不同；失败则返回  NULL 。</p>
<p><strong>【注意】</strong></p>
<p>（1）指针  ptr  必须是在动态内存空间分配成功的指针，形如如下的指针是不可以的： int *i; int a[2]； 会导致运行时错误，可以简单的这样记忆：用  malloc() 、 calloc() 、 realloc()  分配成功的指针才能被  realloc()  函数接受。</p>
<p>（2）成功分配内存后  ptr  将被系统回收，一定不可再对  ptr  指针做任何操作，包括  free(); ，相反的，可以对  realloc()  函数的返回值进行正常操作。</p>
<p>（3）如果是扩大内存操作，若当前内存段后面有需要的内存空间，则直接扩展这段内存空间， realloc() 将返回原指针（但<strong>依旧不能对原指针进行任何操作</strong>）。若当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，会把  ptr  指向的内存中的数据复制到新地址；如果是缩小内存操作，原始据会被复制并截取新长度。</p>
<p>（4）如果分配失败，函数会返回 NULL ，但是 ptr  指向的内存不会被释放，它的内容也不会改变，依然可以正常使用。</p>
<p>（5）同样是使用 free 函数来释放申请的内存。</p>
<h2 id="3-内存释放函数"><a href="#3-内存释放函数" class="headerlink" title="3.内存释放函数"></a><font size=3>3.内存释放函数</font></h2><h3 id="3-1-free"><a href="#3-1-free" class="headerlink" title="3.1 free() "></a><font size=3>3.1 free() </font></h3><p> C  语言中使用 free 函数来释放申请的内存，在 linux 中可以使用 man 3 free 命令查看该函数的手册函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib,h&gt;</span></span></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>【函数说明】</strong>释放动态申请的内存区域，它时需要提供内存区域的起始地址就可以了，那他怎么知道要释放多少字节的内存空间？可以看这篇笔记：《LV05-01-操作系统-内存管理》</p>
<p><strong>【函数参数】</strong></p>
<ul>
<li>ptr ：表示需要释放的内存的起始地址。</li>
</ul>
<p><strong>【返回值】</strong>无</p>
<p><strong>【注意】</strong></p>
<p>（1）<strong>必须提供内存的起始地址</strong>，不能提供一个部分地址，释放内存中的一部分是不允许的。因此，我们必须保存好 malloc 函数返回的指针值，若丢失，则所分配的堆空间就无法被回收，这被称为<strong>内存泄漏</strong>。</p>
<p>（2） malloc 和 free 成对使用，编译器不负责动态内存的释放，需要我们自己进行释放。</p>
<p>（3）释放内存时，不允许重复释放，。同一空间的重复释放也是很危险的，如果该空间重新分配了，那将导致不可知的问题。</p>
<p>（4） free 只释放堆区空间，像代码区、全局变量与静态变量区以及栈区上的变量，都不需要我们显式的去释放，而且也不能通过 free 函数来释放，否则可能会出错。</p>
<h2 id="3-内存分配实例"><a href="#3-内存分配实例" class="headerlink" title="3.内存分配实例"></a><font size=3>3.内存分配实例</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">	p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please input a string:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The string is: %s\n&quot;</span>,p);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在终端执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -Wall # 编译程序 </span><br><span class="line">./a.out          # 执行可执行文件</span><br></pre></td></tr></table></figure>

<p>会看到有如下信息输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = 0x559952fbb260</span><br><span class="line">Please input a string:fanhua</span><br><span class="line">The string is: fanhua</span><br></pre></td></tr></table></figure>

<h1 id="三、内存布局"><a href="#三、内存布局" class="headerlink" title="三、内存布局"></a><font size=3>三、内存布局</font></h1><p>上边了解了堆和栈的相关知识，但是 C 语言程序在内存中究竟是怎样的呢？我们常在 linux 下进行 C 语言程序设计，那么接下来就看一看 Linux 下的一种经典内存布局吧。</p>
<h2 id="1-32-位-Linux"><a href="#1-32-位-Linux" class="headerlink" title="1. 32 位 Linux "></a><font size=3>1. 32 位 Linux </font></h2><p>对于 32 位环境，理论上程序可以拥有  4GB  的虚拟地址空间，我们在 C 语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。但是，在这  4GB  的地址空间中，有一部分是给操作系统内核使用的，应用程序无法直接访问这一段内存，这一部分内存地址被称为<strong>内核空间</strong>（ Kernel Space ）。 Windows  在默认情况下会将高地址的  2GB  空间分配给内核（也可以配置为 1GB ），而  Linux  默认情况下会将高地址的  1GB  空间分配给内核。应用程序便只能使用剩下的  2GB  或  3GB  的地址空间，称为<strong>用户空间</strong>（ User Space ）。</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220419100225475.png" alt="image-20220419100225475" style="zoom: 33%;" />

<details class="folding-tag" blue><summary> 点击查看内存各部分说明 </summary>
              <div class='content'>
              <table>    <tr><td align="center" width=150px>内存分区</td><td align="center">说明</td></tr>    <tr><td align="center" width=150px>程序代码区<br>(code)</td><td align="left">存放函数体的二进制代码。</td></tr>    <tr><td align="center" width=150px>常量区<br>(constant)</td><td align="left">存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。</td></tr>    <tr><td align="center" width=150px>全局数据区<br>(global data)</td><td align="left">存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。</td></tr>    <tr><td align="center" width=150px>堆区<br>(heap)</td><td align="left">一般由我们自己分配和释放，若我们不释放，程序运行结束时由操作系统回收。malloc()、calloc()、free() 等函数操作的就是这块内存。注意：这里所说的堆区与数据结构中的堆不是一个概念，但是堆区的分配方式类似于链表。</td></tr>    <tr><td align="center" width=150px>动态链接库</td><td align="left">用于在程序运行期间加载和卸载动态链接库。</td></tr>    <tr><td align="center" width=150px>栈区<br>(stack)</td><td align="left">存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。</td></tr></table>
              </div>
            </details>

<h2 id="2-64-位-Linux"><a href="#2-64-位-Linux" class="headerlink" title="2. 64 位 Linux "></a><font size=3>2. 64 位 Linux </font></h2><p>在 64 位环境下，虚拟地址空间大小为  256TB ， Linux  将高  128TB  的空间分配给内核使用，而将低  128TB  的空间分配给用户程序使用。</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220419102607390.png" alt="image-20220419102607390" style="zoom:33%;" />

<p>【说明】在 64 位环境下，虚拟地址虽然占用 64 位，但只有最低 48 位有效。任何虚拟地址的 48 位至 63 位必须与 47 位一致。在上图中，用户空间地址的 47 位是 0 ，所以高 16 位也是 0 ，换算成十六进制形式，最高的四个数都是 0 ；内核空间地址的 47 位是 1 ，所以高 16 位也是 1 ，换算成十六进制形式，最高的四个数都是 1 。这样中间的一部分地址正好空出来，也就是图中的“未定义区域”，这部分内存无论如何也访问不到。</p>
<h1 id="四、一个易错点"><a href="#四、一个易错点" class="headerlink" title="四、一个易错点"></a><font size=3>四、一个易错点</font></h1><h2 id="1-代码与现象"><a href="#1-代码与现象" class="headerlink" title="1.代码与现象"></a><font size=3>1.代码与现象</font></h2><p>有这样一段代码，运行后会报段错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_memory</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(p, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">	get_memory(str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">free</span>(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编译，然后运行程序，会的到下边的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = hello world!</span><br><span class="line">str = (null)</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure>

<p>会发现，我们直打印 str 指向的数据的时候，直接报了一个段错误，但是这里其实还有一个疑问，就是 printf 使用 str &#x3D; %s 来打印 str 指向的数据的时候就没有报段错误，自己没查到相关资料，暂时先记录一下，后边搞定了再补充笔记，本次的重点是段错误问题。</p>
<h2 id="2-错误分析"><a href="#2-错误分析" class="headerlink" title="2.错误分析"></a><font size=3>2.错误分析</font></h2><h3 id="2-1-get-memory-调用情况"><a href="#2-1-get-memory-调用情况" class="headerlink" title="2.1 get_memory() 调用情况"></a><font size=3>2.1 get_memory() 调用情况</font></h3><p>在 main 函数中，我们穿建了一个指针变量 str ，并初始化为空，然后调用了一个 get_memory 函数，我们传入了 str ，我们传进去的地址嘛？还是说这是一个值传递，其实这里我是有点迷糊的，因为平时我们可以用函数形参中的指针来接收数组的地址，但是传入一个指针变量的时候，就有些迷了。（可以先看一下这篇笔记《LV01-10-C语言-函数传参问题》，里边有写字符串指针变量在传参的时候的赋值情况）</p>
<p>不过，我们可以打印出来看看啊，看一看进去的到底是个地址还是什么，前边我们知道 printf 直接打印空指针的话会报段错误，但是加上一些修饰的字符串的话，即便是空，我们也可以打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_memory</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;p=%p, p=%s, p=%p\n&quot;</span>, &amp;p, p, p);</span><br><span class="line">	p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;开辟内存后：&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;p=%p, p=%s, p=%p\n&quot;</span>, &amp;p, p, p);</span><br><span class="line">	<span class="built_in">strcpy</span>(p, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;str=%p, str=%s, str=%p\n&quot;</span>, &amp;str, str, str);</span><br><span class="line">	get_memory(str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">free</span>(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行的话，然后我们会得到以下输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;str=0x7ffd845d6140, str=(null), str=(nil)</span><br><span class="line">&amp;p=0x7ffd845d6118, p=(null), p=(nil)</span><br><span class="line">开辟内存后：&amp;p=0x7ffd845d6118, p=, p=0x23d2420</span><br><span class="line">p = hello world!</span><br><span class="line">str = (null)</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure>

<p>【说明】打印出来的 nil 表示地址为空。</p>
<p>会发现，我是我们是将 str 指向的值传递给了 p ，其实分析一下也就是这样的，传参的时候是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p = str;</span><br></pre></td></tr></table></figure>

<h3 id="2-2分配内存前"><a href="#2-2分配内存前" class="headerlink" title="2.2分配内存前"></a><font size=3>2.2分配内存前</font></h3><p>有上边的打印情况，我们分配内存之前的情况如下图：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220918090740953.png" alt="image-20220918090740953" style="zoom:50%;" />

<p>这个时候 p 和 str 都是 null ，可以说是没有任何关系。</p>
<h3 id="2-3分配内存后"><a href="#2-3分配内存后" class="headerlink" title="2.3分配内存后"></a><font size=3>2.3分配内存后</font></h3><p>有上边的打印情况，我们分配内存之后的情况如下图：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220918091147368.png" alt="image-20220918091147368" style="zoom:50%;" />

<p>这个时候 p 和 str 都是 null ，可以说是没有任何关系。</p>
<h3 id="2-4-get-memory-调用结束"><a href="#2-4-get-memory-调用结束" class="headerlink" title="2.4 get_memory() 调用结束"></a><font size=3>2.4 get_memory() 调用结束</font></h3><p>这个函数调用结束后， p 指针变量销毁，没有指针变量指向这片内存区域，就导致了内存泄漏。</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220918091532043.png" alt="image-20220918091532043" style="zoom:50%;" />

<p>而此时 str 依然是 null ，也就是说，整个程序运行期间， p 和 str 其实在传参后，就没有任何关系了， str 仅仅将自己的 null 传给了 p ，之后两者再无任何联系，所以 str 一直都是 null ，所以后边访问空地址才会发生段错误。</p>
<h2 id="3-程序修改"><a href="#3-程序修改" class="headerlink" title="3.程序修改"></a><font size=3>3.程序修改</font></h2><h3 id="3-1方式1"><a href="#3-1方式1" class="headerlink" title="3.1方式1"></a><font size=3>3.1方式1</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">get_memory</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(p, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;str=%p, str=%s, str=%p\n&quot;</span>, &amp;str, str, str);</span><br><span class="line">	str = get_memory(str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">free</span>(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，编译运行之后，我们就会得到想要的结果啦：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;str=0x7ffea0ee9a90, str=(null), str=(nil)</span><br><span class="line">p = hello world!</span><br><span class="line">str = hello world!</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<h3 id="3-2方式2"><a href="#3-2方式2" class="headerlink" title="3.2方式2"></a><font size=3>3.2方式2</font></h3><p> p 和 str 没有关系，我们创造关系，我们传一个二级指针进去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_memory</span><span class="params">(<span class="type">char</span> **p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;p=%p,p=%p,*p=%p,*p=%s\n&quot;</span>, &amp;p, p, *p, *p);</span><br><span class="line">	*p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;开辟内存后：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;p=%p,p=%p,*p=%p,*p=%s\n&quot;</span>, &amp;p, p, *p, *p);</span><br><span class="line">	<span class="built_in">strcpy</span>(*p, <span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;str=%p, str=%s, str=%p\n&quot;</span>, &amp;str, str, str);</span><br><span class="line">	get_memory(&amp;str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">	<span class="built_in">free</span>(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次二级指针变量 p 中存放的就是 str 的地址了，所以有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>我们会得到以下输出信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;str=0x7ffc1c5994a0, str=(null), str=(nil)</span><br><span class="line">&amp;p=0x7ffc1c599468,p=0x7ffc1c5994a0,*p=(nil),*p=(null)</span><br><span class="line">开辟内存后：</span><br><span class="line">&amp;p=0x7ffc1c599468,p=0x7ffc1c5994a0,*p=0x20ed420,*p=</span><br><span class="line">str = hello world!</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-16-C%E8%AF%AD%E8%A8%80-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/image-20220918094201817.png" alt="image-20220918094201817" style="zoom:50%;" />


    </div>

    
    
    

    <footer class="post-footer">




    <div>
        
            <div style="text-align:center;color: #ccc;font-size:14px;">
            ----------本文结束
            <i class="fas fa-fan fa-spin" style="color: #FF1493; font-size: 1rem"></i>
            感谢您的阅读----------
            </div>
        
    </div>





  
  <div class="my_post_copyright"> 
    <p><span>文章标题:</span><a href="/post/342e4ba9.html">LV01-16-C语言-内存管理</a></p>
    <p><span>文章作者:</span><a href="/" title="欢迎访问 《苏木》 的学习笔记">苏木</a></p>
    <p><span>发布时间:</span>2022年03月05日 - 17:43</p>
    <p><span>最后更新:</span>2025年06月14日 - 00:25</p>
    <p><span>原始链接:</span><a href="/post/342e4ba9.html" title="LV01-16-C语言-内存管理">https://sumumm.github.io/post/342e4ba9.html</a></p>
    <p><span>许可协议:</span><i class="fab fa-creative-commons"></i> <a rel="license" href= "https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
  </div>
  


          <div class="post-tags">
              <a href="/tags/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> LV01-C语言基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/f2f92586.html" rel="prev" title="LV02-05-Makefile-01-基础知识">
                  <i class="fa fa-angle-left"></i> LV02-05-Makefile-01-基础知识
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/f72c7684.html" rel="next" title="LV01-15-C语言-自定义数据类型">
                  LV01-15-C语言-自定义数据类型 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">苏木</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.7m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">225:26</span>
  </span>
</div>




    <span id="sitetime"></span>
    <script defer language=javascript>
        function siteTime()
        {
            window.setTimeout("siteTime()", 1000);
            var seconds = 1000;
            var minutes = seconds * 60;
            var hours = minutes * 60;
            var days = hours * 24;
            var years = days * 365;
            var today = new Date();
            var todayYear = today.getFullYear();
            var todayMonth = today.getMonth()+1;
            var todayDate = today.getDate();
            var todayHour = today.getHours();
            var todayMinute = today.getMinutes();
            var todaySecond = today.getSeconds();
            /*==================================================
            Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
            year        - 作为date对象的年份，为4位年份值
            month       - 0-11之间的整数，做为date对象的月份
            day         - 1-31之间的整数，做为date对象的天数
            hours       - 0(午夜24点)-23之间的整数，做为date对象的小时数
            minutes     - 0-59之间的整数，做为date对象的分钟数
            seconds     - 0-59之间的整数，做为date对象的秒数
            microseconds - 0-999之间的整数，做为date对象的毫秒数
            ==================================================*/
            var t1 = Date.UTC(2017, 
                              5, 
                              19, 
                              0, 
                              0, 
                              0); //北京时间
            var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
            var diff = t2-t1;
            var diffYears = Math.floor(diff/years);
            var diffDays = Math.floor((diff/days)-diffYears*365);
            var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
            var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
            var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
            document.getElementById("sitetime").innerHTML="已在这里 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
        }
        siteTime();
    </script>



    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


 
        <div id="click-show-text"
            data-mobile = false
            data-text = 富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善
            data-fontsize = 15px
            data-random= false>
        </div>
       

      
        <script async src=https://cdn.jsdelivr.net/npm/hexo-next-mouse-effect@latest/click/showText.js></script>
      

      
    




    <script async src="/js/fancybox_param.js"></script>





<!-- APlayer本体 -->



</body>
</html>
