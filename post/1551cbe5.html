<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/green/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"sumumm.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":300},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="什么是中断？若笔记中有错误或者不合适的地方，欢迎批评指正😃。">
<meta property="og:type" content="article">
<meta property="og:title" content="LV06-13-中断-01-中断基础">
<meta property="og:url" content="https://sumumm.github.io/post/1551cbe5.html">
<meta property="og:site_name" content="苏木">
<meta property="og:description" content="什么是中断？若笔记中有错误或者不合适的地方，欢迎批评指正😃。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214143155615.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214160237766.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214161211469.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214163356034.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214164010494.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214164104191.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250323165922391.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214145510571.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214145539057.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214145810987.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214150026383.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214150819673.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214151722926.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214151807711.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214152941268.png">
<meta property="article:published_time" content="2025-03-23T10:41:51.000Z">
<meta property="article:modified_time" content="2025-06-13T16:25:57.056Z">
<meta property="article:author" content="苏木">
<meta property="article:tag" content="LV06-驱动开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214143155615.png">


<link rel="canonical" href="https://sumumm.github.io/post/1551cbe5.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"https://sumumm.github.io/post/1551cbe5.html","path":"post/1551cbe5.html","title":"LV06-13-中断-01-中断基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LV06-13-中断-01-中断基础 | 苏木</title>
  








    <script src="/js/browser_tools_disable.js"></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.com/hexo-next-tags-plus@latest/lib/tag_plus.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">苏木</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我的学习之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>苏木的家</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类页<span class="badge">42</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档页<span class="badge">673</span></a></li><li class="menu-item menu-item-flink"><a href="/flink/" rel="section"><i class="fa fa-link fa-fw"></i>友人帐</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="nav-text">一、异常与中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="nav-text">1. 什么是中断？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%AD%E6%96%AD%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-text">2. 中断有什么用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="nav-text">3. 什么是异常？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-text">4. 中断的处理流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="nav-text">二、中断子系统框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8-GIC"><span class="nav-text">1. 中断控制器 GIC  </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-GIC%E7%AE%80%E4%BB%8B"><span class="nav-text">1.1 GIC简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-Distributor-%E4%B8%AD%E6%96%AD%E4%BB%B2%E8%A3%81%E5%99%A8"><span class="nav-text">1.1.1 Distributor 中断仲裁器  </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-Redistributor-%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-text">1.1.2 Redistributor 重新分配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-CPU-%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.1.3 CPU 接口  </span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="nav-text">1.2 中断类型  </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">2. 中断处理的状态  </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%B8%A4%E4%B8%AA%E4%B8%AD%E6%96%AD%E5%8F%B7%EF%BC%9F"><span class="nav-text">3. 两个中断号？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BB%8E%E6%BA%90%E7%A0%81%E4%B8%8A%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%B8%AA%E6%A1%86%E6%9E%B6"><span class="nav-text">4. 从源码上看看这个框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-irqchip-init"><span class="nav-text">4.1 irqchip_init()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-irqchip-of-table"><span class="nav-text">4.2 __irqchip_of_table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-of-irq-init"><span class="nav-text">4.3 of_irq_init()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-gic-of-init"><span class="nav-text">4.4 gic_of_init()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E8%AF%B4%E6%98%8E"><span class="nav-text">4.5 说明</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81Linux-%E7%B3%BB%E7%BB%9F%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">三、Linux 系统对中断的处理  </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E4%B8%AD%E6%96%AD%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9A%E6%A0%88"><span class="nav-text">1. 进程、线程、中断的核心：栈  </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-ARM-%E5%A4%84%E7%90%86%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text">1.1 ARM 处理器程序运行的过程  </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%A8%8B%E5%BA%8F%E8%A2%AB%E4%B8%AD%E6%96%AD%E6%97%B6%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98%E7%8E%B0%E5%9C%BA"><span class="nav-text">1.2 程序被中断时，怎么保存现场  </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1.3 进程、线程的概念  </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Linux-%E7%B3%BB%E7%BB%9F%E5%AF%B9%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-text">2. Linux 系统对中断处理的演进  </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-Linux-%E5%AF%B9%E4%B8%AD%E6%96%AD%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%9A%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD%E3%80%81%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%96%AD"><span class="nav-text">2.1 Linux 对中断的扩展：硬件中断、软件中断  </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD"><span class="nav-text">2.1.1 硬件中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E8%BD%AF%E4%BB%B6%E4%B8%AD%E6%96%AD"><span class="nav-text">2.1.2 软件中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%8E%9F%E5%88%99-1%EF%BC%9A%E4%B8%8D%E8%83%BD%E5%B5%8C%E5%A5%97"><span class="nav-text">2.2 中断处理原则 1：不能嵌套  </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%8E%9F%E5%88%99-2%EF%BC%9A%E8%B6%8A%E5%BF%AB%E8%B6%8A%E5%A5%BD"><span class="nav-text">2.3 中断处理原则 2：越快越好  </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-%E6%8B%86%E5%88%86%E4%B8%BA%EF%BC%9A%E4%B8%8A%E5%8D%8A%E9%83%A8%E3%80%81%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="nav-text">2.3.1 拆分为：上半部、下半部  </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-%E4%B8%8B%E5%8D%8A%E9%83%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">2.3.2 下半部的实现机制有哪些？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%80%BB%E7%BB%93"><span class="nav-text">3. 总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苏木"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">苏木</p>
  <div class="site-description" itemprop="description">莫道桑榆晚，为霞尚满天</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">673</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sumumm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sumumm" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sumumm.github.io/post/1551cbe5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="苏木">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏木">
      <meta itemprop="description" content="莫道桑榆晚，为霞尚满天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LV06-13-中断-01-中断基础 | 苏木">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LV06-13-中断-01-中断基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-23 18:41:51" itemprop="dateCreated datePublished" datetime="2025-03-23T18:41:51+08:00">2025-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">嵌入式开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/" itemprop="url" rel="index"><span itemprop="name">02IMX6ULL平台</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">LV06-驱动开发</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>44 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>什么是中断？若笔记中有错误或者不合适的地方，欢迎批评指正😃。</p>
<span id="more"></span>

<!-- Photo: https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/ -->

<details class="folding-tag" blue><summary> 点击查看使用工具及版本 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center" rowspan="5">PC端开发环境</td>        <td align="center" width=150px>Windows</td>        <td align="left">Windows11</td>    </tr>    <tr>        <td align="center">Ubuntu</td>        <td align="left">Ubuntu20.04.2的64位版本</td>      </tr>    <tr>        <td align="center">VMware® Workstation 17 Pro</td>        <td align="left">17.6.0 build-24238078</td>      </tr>    <tr>        <td align="center">终端软件</td>        <td align="left">MobaXterm(Professional Edition v23.0 Build 5042 (license))</td>    </tr>    <tr>        <td align="center">Win32DiskImager</td>        <td align="left">Win32DiskImager v1.0</td>      </tr>    <tr>        <td align="center" rowspan="3">Linux开发板环境</td>        <td align="center">Linux开发板</td>        <td align="left">正点原子 i.MX6ULL Linux 阿尔法开发板</td>      </tr>    <tr>        <td align="center">uboot</td>        <td align="left">NXP官方提供的uboot，使用的uboot版本为U-Boot 2019.04</td>      </tr>    <tr>        <td align="center">linux内核</td>        <td align="left">linux-4.19.71(NXP官方提供)</td>      </tr></table>
              </div>
            </details>

<details class="folding-tag" blue><summary> 点击查看本文参考资料 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center">分类</td>        <td align="center">网址</td>        <td align="center">说明</td>    </tr>    <tr>        <td align="center" rowspan="5">官方网站</td>        <td align="left"><a href="https://www.arm.com/" target="_blank">https://www.arm.com/</a></td>        <td align="left">ARM官方网站，在这里我们可以找到Cotex-Mx以及ARMVx的一些文档</td>    </tr>    <tr>        <td align="left"><a href="https://www.nxp.com.cn/" target="_blank">https://www.nxp.com.cn/ </a></td>        <td align="left">NXP官方网站</td>    </tr>    <tr>        <td align="left"><a href="https://www.nxpic.org.cn/" target="_blank">https://www.nxpic.org.cn/</a></td><td align="left">NXP 官方社区</td>    </tr>    <tr>        <td align="left"><a href="https://u-boot.readthedocs.io/en/latest/" target="_blank">https://u-boot.readthedocs.io/en/latest/</a></td><td align="left">u-boot官网</td>    </tr>    <tr>        <td align="left"><a href="https://www.kernel.org/" target="_blank">https://www.kernel.org/</a></td><td align="left">linux内核官网</td>    </tr></table>
              </div>
            </details>

<details class="folding-tag" blue><summary> 点击查看相关文件下载 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center">分类</td>        <td align="center">网址</td>        <td align="center">说明</td>    </tr>    <tr>        <td align="center" rowspan="3">NXP</td>        <td align="left"><a href="https://github.com/nxp-imx" target="_blank">https://github.com/nxp-imx</a></td>        <td align="left">NXP imx开发资源GitHub组织，里边会有u-boot和linux内核的仓库</td>    </tr>    <tr>        <td align="left"><a href="https://github.com/nxp-imx/linux-imx/releases/tag/v4.19.71" target="_blank">nxp-imx/linux-imx/releases/tag/v4.19.71</a></td>        <td align="left">NXP linux内核仓库tags中的v4.19.71</td>    </tr>    <tr>        <td align="left"><a href="https://github.com/nxp-imx/uboot-imx/releases/tag/rel_imx_4.19.35_1.1.0" target="_blank">nxp-imx/uboot-imx/releases/tag/rel_imx_4.19.35_1.1.0</a></td>        <td align="left">NXP u-boot仓库tags中的rel_imx_4.19.35_1.1.0</td>    </tr>    <tr>        <td align="center" rowspan="2">I.MX6ULL</td>        <td align="left"><a href="https://www.nxp.com.cn/docs/en/data-sheet/IMX6ULLIEC.pdf" target="_blank">i.MX 6ULL Applications Processors for Industrial Products</a></td>        <td align="left">I.MX6ULL 芯片手册（datasheet，可以在线查看）</td>    </tr>    <tr>        <td align="left"><a href="https://www.nxp.com.cn/webapp/Download?colCode=IMX6ULLRM&lang_cd=zh" target="_blank">i.MX 6ULL Applications ProcessorReference Manual</a></td>        <td align="left">I.MX6ULL 参考手册（下载后才能查看，需要登录NXP官网）</td>    </tr>    <tr>        <td align="center" rowspan="3">Source Code</td>        <td align="left"><a href="https://elixir.bootlin.com/linux/latest/source" target="_blank">https://elixir.bootlin.com/linux/latest/source</a></td>        <td align="left">linux kernel源码</td>    </tr>    <tr>        <td align="left"><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/?h=v4.19.71&id=e7d2672c66e4d3675570369bf20856296da312c4" target="_blank">kernel/git/stable/linux.git - Linux kernel stable tree</a></td>        <td align="left">linux kernel源码(官网,tag 4.19.71)</td>    </tr>    <tr>        <td align="left"><a href="https://elixir.bootlin.com/u-boot/latest/source" target="_blank">https://elixir.bootlin.com/u-boot/latest/source</a></td>        <td align="left">uboot源码</td>    </tr></table>
              </div>
            </details>

<h1 id="一、异常与中断"><a href="#一、异常与中断" class="headerlink" title="一、异常与中断"></a><font size=3>一、异常与中断</font></h1><h2 id="1-什么是中断？"><a href="#1-什么是中断？" class="headerlink" title="1. 什么是中断？"></a><font size=3>1. 什么是中断？</font></h2><p>中断是指在 CPU 正常运行期间， 由外部或内部事件引起的一种机制。 当中断发生时， CPU会停止当前正在执行的程序， 并转而执行触发该中断的中断处理程序。 处理完中断处理程序后， CPU 会返回到中断发生的地方， 继续执行被中断的程序。 中断机制允许 CPU 在实时响应外部或内部事件的同时， 保持对其他任务的处理能力。  </p>
<p>举个例子，有这样的一个场景，我们正在看书，这就是我们主要的任务，现在发生了下边的事：</p>
<p>（1）厨房灶台上的水烧开了</p>
<p>（2）有电话到来</p>
<p>这些事情发生的时候，我们就不得不去处理，我们该怎么办？</p>
<p>（1）书中放上书签，合上书（保存现场，以免一会回来找不到自己看到哪里了）</p>
<p>（2）处理刚才的两件事，水烧开了就将煤气关掉，把开水装起来，电话到来，就接听电话，先做哪个？那就看哪个更紧急啦。处理这两件事就要“中断”前面看书的过程。</p>
<p>（3）回来继续看书（恢复现场）。</p>
<p>如下图：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214143155615.png" alt="image-20250214143155615" style="zoom: 67%;" />

<h2 id="2-中断有什么用？"><a href="#2-中断有什么用？" class="headerlink" title="2. 中断有什么用？"></a><font size=3>2. 中断有什么用？</font></h2><p>在上面的场景中， 作为唯一具有处理能力的主体， 我们一次只能专注于一个任务， 可以等待水烧开、 看书等等。 然而， 当我们专心致志地完成一项任务时， 常常会有紧迫或不紧迫的其他事情突然出现， 需要我们关注和处理。 有些情况甚至要求我们立即停下手头的工作来应对。只有在处理完这些中断事件之后， 我们才能回到先前的任务。  </p>
<p>中断机制赋予了我们处理意外情况的能力， 而且如果我们能充分利用这个机制， 就能够同时完成多个任务。 回到烧水的例子， 无论我们是否在厨房， 煤气灶都会将水烧开。 我们只需要在水烧开后及时关掉煤气。 为了避免在厨房等待的时间， 而水烧开时产生的声音就是中断信号，提醒我们炉子上的水已经烧开。 这样， 我们就可以在等待的时间里做其他事情， 比如看书。当水壶烧开发出声音之后， 它会打断当前的任务， 提醒水已经烧开， 这时只需要前往厨房关掉煤气即可。  </p>
<p>中断机制使我们能够有条不紊地同时处理多个任务， 从而提高了并发处理能力。 类似地，计算机系统中也使用中断机制来应对各种外部事件。 例如， 在键盘输入时， 会发送一个中断信号给 CPU， 以便及时响应用户的操作。 这样， CPU 就不必一直轮询键盘的状态， 而可以专注于其他任务。 中断机制还可以用于处理硬盘读写完成、 网络数据包接收等事件， 提高了系统的资源利用率和并发处理能力。  </p>
<h2 id="3-什么是异常？"><a href="#3-什么是异常？" class="headerlink" title="3. 什么是异常？"></a><font size=3>3. 什么是异常？</font></h2><p>由<strong>CPU内部</strong>产生的意外事件被称为异常，也叫内中断。<strong>异常</strong>是CPU执行一条指令时，由CPU在其<strong>内部</strong>检测到的、与正在执行的指令<strong>相关</strong>的<strong>同步事件</strong>；中断是一种典型的由外部设备触发的、与当前正在执行的指令无关的异步事件。</p>
<p>这里我们不深入了解异常，因为这里主要是学习中断。</p>
<h2 id="4-中断的处理流程"><a href="#4-中断的处理流程" class="headerlink" title="4. 中断的处理流程"></a><font size=3>4. 中断的处理流程</font></h2><p>arm 对异常(中断)处理过程：</p>
<ul>
<li><p>（1）中断相关的初始化：（a) 设置中断源，让它可以产生中断。（b) 设置中断控制器(可以屏蔽某个中断，优先级)。（c) 设置 CPU 总开关(使能中断)。</p>
</li>
<li><p>（2）执行其他程序：正常程序</p>
</li>
<li><p>（3）产生中断：比如按下按键→中断控制器→CPU</p>
</li>
<li><p>（4）CPU 每执行完一条指令都会检查有无中断&#x2F;异常产生</p>
</li>
<li><p>（5）CPU 发现有中断&#x2F;异常产生，开始处理。对于不同的异常，跳去不同的地址执行程序。这些地址上，只是一条跳转指令，跳去执行某个函数(地址)，这个就是异常向量。（3）（4）（5）都是硬件做的。这些函数做什么事情？软件做的事情：（a) 保存现场(各种寄存器)（b) 处理异常(中断)：分辨中断源，再调用不同的处理函数（c) 恢复现场</p>
</li>
</ul>
<h1 id="二、中断子系统框架"><a href="#二、中断子系统框架" class="headerlink" title="二、中断子系统框架"></a><font size=3>二、中断子系统框架</font></h1><p>一个完整的中断子系统框架可以分为四个层次， 由上到下分别为用户层、 通用层、 硬件相关层和硬件层， 每个层相关的介绍如下：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214160237766.png" alt="image-20250214160237766"  />

<p>用户层： 用户层是中断的使用者， 主要包括各类设备驱动。 这些驱动程序通过中断相关的接口进行中断的申请和注册。 当外设触发中断时， 用户层驱动程序会进行相应的回调处理， 执行特定的操作。  </p>
<p>通用层： 通用层也可称为框架层， 它是硬件无关的层次。 通用层的代码在所有硬件平台上都是通用的， 不依赖于具体的硬件架构或中断控制器。 通用层提供了统一的接口和功能， 用于管理和处理中断， 使得驱动程序能够在不同的硬件平台上复用。  </p>
<p>硬件相关层： 硬件相关层包含两部分代码。 一部分是与特定处理器架构相关的代码， 比如ARM64 处理器的中断处理相关代码。 这些代码负责处理特定架构的中断机制， 包括中断向量表、 中断处理程序等。 另一部分是中断控制器的驱动代码， 用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。</p>
<p>硬件层： 硬件层位于最底层， 与具体的硬件连接相关。 它包括外设与 SoC（系统片上芯片）的物理连接部分。 中断信号从外设传递到中断控制器， 由中断控制器统一管理和路由到处理器。硬件层的设计和实现决定了中断信号的传递方式和硬件的中断处理能力。  </p>
<h2 id="1-中断控制器-GIC"><a href="#1-中断控制器-GIC" class="headerlink" title="1. 中断控制器 GIC  "></a><font size=3>1. 中断控制器 GIC  </font></h2><p>从硬件角度来看，中断由CPU、中断控制器（Interrupt Controller），其他外设 组成。各个外设在硬件上是通过中断线（irq request line）与CPU相连的，在复杂的系统中，外设比较多的情况下，就需要一个<strong>中断控制器</strong>来协助CPU进行中断的处理，比如ARM架构下的GIC，或者X86架构中的APIC。根据外设的多少，Interrupt Controller可以级联。</p>
<h3 id="1-1-GIC简介"><a href="#1-1-GIC简介" class="headerlink" title="1.1 GIC简介"></a><font size=3>1.1 GIC简介</font></h3><p>中断控制器 GIC（Generic Interrupt Controller） 是中断子系统框架硬件层中的一个关键组件，用于管理和控制中断。 它接收来自各种中断源的中断请求， 并根据预先配置的中断优先级、 屏蔽和路由规则， 将中断请求分发给适当的处理器核心或中断服务例程。  </p>
<p>GIC 是由 ARM 公司提出设计规范， 当前有四个版本， GIC V1-V4（V2最多支持8个ARM core，V3&#x2F;V4支持更多的ARM core，主要用于ARM64服务器系统结构）。 设计规范中最常用的， 有3 个版本 V2.0、 V3.1、 V4.1， GICv3 版本设计主要运行在 Armv8-A, Armv9-A 等架构上。 ARM 公司并给出一个实际的控制器设计参考， 比如 GIC-400(支持 GIC v2 架构)、 gic500(支持 GIC v3 架构)、 GIC-600(支持 GIC v3 和 GIC v4 架构)。 最终芯片厂商可以自己实现 GIC 或者直接购买 ARM提供的设计。  </p>
<p>具体GIC硬件的实现形态有两种，一种是在ARM vensor研发自己的SOC的时候，会向ARM公司购买GIC的IP，这些IP包括的型号有：PL390，GIC-400，GIC-500。其中GIC-500最多支持128个 cpu core，它要求ARM core必须是ARMV8指令集的（例如Cortex-A57），符合GIC architecture specification version 3。另外一种形态是ARM vensor直接购买ARM公司的Cortex A9或者A15的IP，Cortex A9或者A15中会包括了GIC的实现，当然，这些实现也是符合GIC V2的规格。</p>
<p>每个 GIC 版本及相应特性如下表  </p>
<table>
    <tr><td align="center">版本 </td><td align="center">关键特性</td><td align="center" width=300px>常用核心</td></tr>
<tr><td align="center">GICv1</td><td align="left">-支持最多八个处理器核心（PE）<br>- 支持最多 1020 个中断 ID</td><td align="left">ARM Cortex-A5 MPCore<br/>ARM Cortex-A9 MPCore<br/>ARM Cortex-R7 MPCore</td></tr>
<tr><td align="center">GICv2</td><td align="left">- GICv1 的所有关键特性<br/>-支持虚拟化</td><td align="left">ARM Cortex-A7 MPCore<br/>ARM Cortex-A15 MPCore<br/>ARM Cortex-A53 MPCore<br/>ARM Cortex-A57 MPCore</td></tr>
<tr><td align="center">GICv3</td><td align="left">- GICv2 的所有关键特性<br/>-支持超过 8 个处理器核心<br>-支持基于消息的中断<br/>-支持超过 1020 个中断 ID<br/>- CPU 接口寄存器的系统寄存器访问<br/>-增强的安全模型， 分离安全和非安全的 Group 1 中断</td><td align="left">ARM Cortex-A53MPCore<br/>ARM Cortex-A57MPCore<br/>ARM Cortex-A72 MPCore</td></tr>
<tr><td align="center">GICv4</td><td align="left">- GICv3 的所有关键特性<br/>-虚拟中断的直接注入</td><td align="left">ARM Cortex-A53 MPCore<br/>ARMCortex-A57MPCore<br/>ARM Cortex-A72 MPCore</td></tr>
</table>

<p>这里拿RK3568（因为这里刚好有张图，比较容易理解）的举个例子，在 RK3568 上使用的 GIC 版本为 GICv3， 相应的中断控制器模型：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214161211469.png" alt="image-20250214161211469"  />

<blockquote>
<p>GIC相关文档可以看这里：</p>
<p><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/198123/0302/?lang=en">Learn the architecture - Generic Interrupt Controller v3 and v4, Overview</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ihi0048/latest">ARM Generic Interrupt Controller Architecture Specification - Version 2.0 (B.b)</a></p>
</blockquote>
<p>GIC 中断控制器可以分为 Distributor 接口、 Redistributor 接口和 CPU 接口。</p>
<h4 id="1-1-1-Distributor-中断仲裁器"><a href="#1-1-1-Distributor-中断仲裁器" class="headerlink" title="1.1.1 Distributor 中断仲裁器  "></a><font size=3>1.1.1 Distributor 中断仲裁器  </font></h4><p>含影响所有处理器核心中断的全局设置。 包含以下编程接口 ：</p>
<ul>
<li><p>启用和禁用 SPI。</p>
</li>
<li><p>设置每个 SPI 的优先级级别。</p>
</li>
<li><p>每个 SPI 的路由信息。</p>
</li>
<li><p>将每个 SPI 设置为电平触发或边沿触发。</p>
</li>
<li><p>生成基于消息的 SPI。</p>
</li>
<li><p>控制 SPI 的活动和挂起状态。</p>
</li>
<li><p>用于确定在每个安全状态中使用的程序员模型的控制（亲和性路由或遗留模型） 。</p>
</li>
</ul>
<h4 id="1-1-2-Redistributor-重新分配器"><a href="#1-1-2-Redistributor-重新分配器" class="headerlink" title="1.1.2 Redistributor 重新分配器"></a><font size=3>1.1.2 Redistributor 重新分配器</font></h4><p>对于每个连接的处理器核心（PE） ， 都有一个重新分配器（Redistributor） 。 重新分配器提供以下编程接口：</p>
<ul>
<li><p>启用和禁用 SGI（软件生成的中断） 和 PPI（处理器专用中断） 。</p>
</li>
<li><p>设置 SGI 和 PPI 的优先级级别。</p>
</li>
<li><p>将每个 PPI 设置为电平触发或边沿触发。</p>
</li>
<li><p>将每个 SGI 和 PPI 分配给一个中断组。</p>
</li>
<li><p>控制 SGI 和 PPI 的状态。</p>
</li>
<li><p>对支持关联 LP（I 低功耗中断）的中断属性和挂起状态的内存中的数据结构进行基址控制。</p>
</li>
<li><p>支持与连接的处理器核心的电源管理。</p>
</li>
</ul>
<h4 id="1-1-3-CPU-接口"><a href="#1-1-3-CPU-接口" class="headerlink" title="1.1.3 CPU 接口  "></a><font size=3>1.1.3 CPU 接口  </font></h4><p>每个重新分配器都连接到一个 CPU 接口。 CPU 接口提供以下编程接口：</p>
<ul>
<li>通用控制和配置， 用于启用中断处理。</li>
<li>确认中断。</li>
<li>执行中断的优先级降低和停用。</li>
<li>为处理器核心设置中断优先级屏蔽。</li>
<li>定义处理器核心的抢占策略。</li>
<li>确定处理器核心最高优先级的挂起中断。</li>
</ul>
<h3 id="1-2-中断类型"><a href="#1-2-中断类型" class="headerlink" title="1.2 中断类型  "></a><font size=3>1.2 中断类型  </font></h3><p>GIC-V3 支持四种类型的中断， 分别是 SGI、 PPI、 SPI 和 LPI， 每个中断类型的介绍如下：</p>
<ul>
<li><p>SGI（Software Generated Interrupt， 软件生成中断） ： SGI 是通过向 GIC 中的 SGI 寄存器写入来生成的中断。 它通常用于处理器之间的通信， 允许一个 PE 发送中断给一个或多个指定的 PE， 中断号 ID0 - ID15 用于 SGI。  </p>
</li>
<li><p>PPI（I Private Peripheral Interrupt， 私有外设中断） ： 针对特定 PE 的外设中断。 不与其他 PE共享， 中断号 ID16 - ID31 用于 PPI。</p>
</li>
<li><p>SPI（Shared Peripheral Interrupt， 共享外设中断） ： 全局外设中断， 可以路由到指定的处理器核心（PE） 或一组 PE， 它允许多个 PE 接收同一个中断。 中断号 ID32 - ID1019 用于 SPI。</p>
</li>
<li><p>LPI（Locality-specific Peripheral Interrupt， 特定局部外设中断） ： LPI 是 GICv3 中引入的一种中断类型， 与其他类型的中断有几个不同之处。 LPI 总是基于消息的中断， 其配置存储在内存表中， 而不是寄存器中。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">INTID 范围</th>
<th>中断类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0 - 15</td>
<td>SGI（软件生成中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td align="left">16 - 31</td>
<td>PPI（私有外设中断）</td>
<td>每个核心分别存储</td>
</tr>
<tr>
<td align="left">32 - 1019</td>
<td>SPI（共享外设中断）</td>
<td></td>
</tr>
<tr>
<td align="left">1020 - 1023</td>
<td>特殊中断号</td>
<td>用于表示特殊情况</td>
</tr>
<tr>
<td align="left">1024 - 8191</td>
<td>保留</td>
<td></td>
</tr>
<tr>
<td align="left">8192 及更大</td>
<td>LPI（特定局部外设中断）</td>
<td>上限由实现定义</td>
</tr>
</tbody></table>
<h2 id="2-中断处理的状态"><a href="#2-中断处理的状态" class="headerlink" title="2. 中断处理的状态  "></a><font size=3>2. 中断处理的状态  </font></h2><p>中断处理的状态机如下图：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214163356034.png" alt="image-20250214163356034"  />

<ul>
<li>Inactive（非活动状态） ： 中断源当前未被触发。</li>
<li>Pending（等待状态） ： 中断源已被触发， 但尚未被处理器核心确认。</li>
<li>Active（活动状态） ： 中断源已被触发， 并且已被处理器核心确认。</li>
<li>Active and Pending（活动且等待状态） ： 已确认一个中断实例， 同时另一个中断实例正在等待处理。</li>
</ul>
<p>每个外设中断可以是以下两种类型之一  :</p>
<p>边沿触发（Edge-triggered） ：这是一种在检测到中断信号上升沿时触发的中断， 然后无论信号状态如何， 都保持触发状态， 直到满足本规范定义的条件来清除中断。</p>
<p>电平触发（Level-sensitive） ：这是一种在中断信号电平处于活动状态时触发的中断， 并且在电平不处于活动状态时取消触发。</p>
<h2 id="3-两个中断号？"><a href="#3-两个中断号？" class="headerlink" title="3. 两个中断号？"></a><font size=3>3. 两个中断号？</font></h2><p>在 linux 内核中， 我们使用 IRQ number 和 HW interrupt ID 两个 ID 来标识一个来自外设的中断：  </p>
<p><strong>IRQ number</strong>： CPU 需要为每一个外设中断编号， 我们称之 IRQ Number。 这个 IRQ number是一个<strong>虚拟的 interrupt ID</strong>， 和硬件无关， 仅仅是被 CPU 用来标识一个外设中断。 我们后面使用imx6ull的时候，申请的GPIO1_IO18对应的中断号就是79，但是根据参考手册，上面就事99，这就是不一样的，这里的99应该是下面要提到的HW interrupt ID。</p>
<p><strong>HW interrupt ID</strong>： 对于 GIC 中断控制器而言， 它收集了多个外设的 interrupt request line 并向上传递， 因此， GIC 中断控制器需要对外设中断进行编码。 GIC 中断控制器用 HW interrupt ID来标识外设的中断。 如果只有一个 GIC 中断控制器， 那 IRQ number 和 HW interrupt ID 是可以一一对应的， 如下图  </p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214164010494.png" alt="image-20250214164010494" style="zoom: 15%;" />

<p>但如果是在 GIC 中断控制器级联的情况下， 仅仅用 HW interrupt ID 就不能唯一标识一个外设中断， 还需要知道该 HW interrupt ID 所属的 GIC 中断控制器（ HW interrupt ID 在不同的Interrupt controller 上是会重复编码的） ：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214164104191.png" alt="image-20250214164104191" style="zoom:25%;" />

<p>这样， CPU 和中断控制器在标识中断上就有了一些不同的概念， 但是， 对于驱动开发者而言， 我们和 CPU 视角是一样的， 我们只希望得到一个 IRQ number， 而不关系具体是那个 GIC中断控制器上的那个 HW interrupt ID。 这样一个好处是在中断相关的硬件发生变化的时候， 驱动软件不需要修改。 因此， linux kernel 中的中断子系统需要提供一个将 HW interrupt ID 映射到IRQ number 上来的机制， 也就是 irq domain。  </p>
<blockquote>
<p>Linux kernel中使用IRQ domain来描述一个中断控制器所管理的中断源。也就是说，每个中断控制器都有自己的domain，可以将IRQ Domain看作是Interrupt controller的软件抽象。</p>
<p>这里的Interrupt controller并不仅仅是指传统意义上的中断控制器，如GIC，也可以代表一种“虚拟”的中断控制器，如GPIO 控制器。GPIO控制器也可以注册一个IRQ domain来管理GPIO中断，所以它也可以实现成为一个虚拟的中断控制器。</p>
</blockquote>
<h2 id="4-从源码上看看这个框架"><a href="#4-从源码上看看这个框架" class="headerlink" title="4. 从源码上看看这个框架"></a><font size=3>4. 从源码上看看这个框架</font></h2><h3 id="4-1-irqchip-init"><a href="#4-1-irqchip-init" class="headerlink" title="4.1 irqchip_init()"></a><font size=3>4.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/irqchip/irqchip.c#L27">irqchip_init()</a></font></h3><p>按照这个调用关系可以找到<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/irqchip/irqchip.c#L27">irqchip_init()</a>函数：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/init/main.c#L637">start_kernel()</a>&rarr;<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/arch/arm/kernel/irq.c#L87">init_IRQ()</a>&rarr;<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/irqchip/irqchip.c#L27">irqchip_init()</a>(有设备树的情况)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">irqchip_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	of_irq_init(__irqchip_of_table);</span><br><span class="line">	acpi_probe_device_table(irqchip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-irqchip-of-table"><a href="#4-2-irqchip-of-table" class="headerlink" title="4.2 __irqchip_of_table"></a><font size=3>4.2 __irqchip_of_table</font></h3><p>__irqchip_of_table是什么？这里有它的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">irqchip_of_table</span>[];</span></span><br></pre></td></tr></table></figure>

<p>以通用的 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/irqchip/irq-gic.c">irq-gic.c - drivers&#x2F;irqchip&#x2F;irq-gic.c</a> 为例，通过<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/irqchip.h#L27">IRQCHIP_DECLARE</a>这个宏定义若干个静态的struct of_device_id常量：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250323165922391.png" alt="image-20250323165922391" />

<p>编译系统会把所有的IRQCHIP_DECLARE宏定义的数据放入到一个特殊的section中(__irqchip_of_table）,我们称这个特殊的section叫做irq chip table，这个table也就保存了kernel支持的所有的中断控制器的ID信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF) &amp;&amp; !defined(MODULE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OF_DECLARE(table, name, compat, fn, fn_type)			\</span></span><br><span class="line"><span class="meta">	static const struct of_device_id __of_table_##name		\</span></span><br><span class="line"><span class="meta">		__used __section(__##table##_of_table)			\</span></span><br><span class="line"><span class="meta">		 = &#123; .compatible = compat,				\</span></span><br><span class="line"><span class="meta">		     .data = (fn == (fn_type)NULL) ? fn : fn  &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OF_DECLARE(table, name, compat, fn, fn_type)			\</span></span><br><span class="line"><span class="meta">	static const struct of_device_id __of_table_##name		\</span></span><br><span class="line"><span class="meta">		__attribute__((unused))					\</span></span><br><span class="line"><span class="meta">		 = &#123; .compatible = compat,				\</span></span><br><span class="line"><span class="meta">		     .data = (fn == (fn_type)NULL) ? fn : fn &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_DECLARE_2(table, name, compat, fn) \</span></span><br><span class="line"><span class="meta">		_OF_DECLARE(table, name, compat, fn, of_init_fn_2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQCHIP_DECLARE(name, compat, fn) OF_DECLARE_2(irqchip, name, compat, fn)</span></span><br></pre></td></tr></table></figure>

<p>我们以下面这个 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/irqchip/irq-gic.c#L1484">cortex_a15_gic</a> 为例看一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IRQCHIP_DECLARE(gic_400, <span class="string">&quot;arm,gic-400&quot;</span>, gic_of_init);</span><br></pre></td></tr></table></figure>

<p>对应的compatible为”arm,gic-400”，data字段这是 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/irqchip/irq-gic.c#L1438">gic_of_init()</a>函数。我们打开我们的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/arch/arm/boot/dts/imx6ul.dtsi#L96">imx6ul.dtsi</a>，找到对应的设备树节点为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@a01000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;arm,gic-400&quot;</span>, <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;</span><br><span class="line">	interrupts = &lt;GIC_PPI <span class="number">9</span> (GIC_CPU_MASK_SIMPLE(<span class="number">4</span>) | IRQ_TYPE_LEVEL_HIGH)&gt;;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	interrupt-parent = &lt;&amp;intc&gt;;</span><br><span class="line">	reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line">	      &lt;<span class="number">0x00a02000</span> <span class="number">0x2000</span>&gt;,</span><br><span class="line">	      &lt;<span class="number">0x00a04000</span> <span class="number">0x2000</span>&gt;,</span><br><span class="line">	      &lt;<span class="number">0x00a06000</span> <span class="number">0x2000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-of-irq-init"><a href="#4-3-of-irq-init" class="headerlink" title="4.3 of_irq_init()"></a><font size=3>4.3 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/of/irq.c#L473">of_irq_init()</a></font></h3><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/of/irq.c#L473">of_irq_init()</a>函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">of_irq_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>, *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_intc_desc</span> *<span class="title">desc</span>, *<span class="title">temp_desc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">intc_desc_list</span>, <span class="title">intc_parent_list</span>;</span></span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;intc_desc_list);</span><br><span class="line">	INIT_LIST_HEAD(&amp;intc_parent_list);</span><br><span class="line">	<span class="comment">//在所有的device node中寻找定义了interrupt-controller属性的中断控制器节点并匹配of_device_id ，形成树状结构</span></span><br><span class="line">	for_each_matching_node_and_match(np, matches, &amp;match) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!of_property_read_bool(np, <span class="string">&quot;interrupt-controller&quot;</span>) ||</span><br><span class="line">				!of_device_is_available(np))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">		desc = kzalloc(<span class="keyword">sizeof</span>(*desc), GFP_KERNEL);<span class="comment">//分配内存</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(!desc)) &#123;</span><br><span class="line">			of_node_put(np);</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//data既是IRQCHIP_DECLARE里的最后一个参数，宏展开既是of_device_id的data字段,of_device_id的第二个参数既是compatible,用来和dts匹配的</span></span><br><span class="line">		desc-&gt;irq_init_cb = match-&gt;data;</span><br><span class="line">		desc-&gt;dev = of_node_get(np);</span><br><span class="line">		desc-&gt;interrupt_parent = of_irq_find_parent(np);</span><br><span class="line">		<span class="keyword">if</span> (desc-&gt;interrupt_parent == np)</span><br><span class="line">			desc-&gt;interrupt_parent = <span class="literal">NULL</span>;</span><br><span class="line">		list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_desc_list); <span class="comment">//挂入链表</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The root irq controller is the one without an interrupt-parent.</span></span><br><span class="line"><span class="comment">	 * That one goes first, followed by the controllers that reference it,</span></span><br><span class="line"><span class="comment">	 * followed by the ones that reference the 2nd level controllers, etc.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//从根节点开始，依次递进到下一个level的interrupt controller</span></span><br><span class="line">	<span class="keyword">while</span> (!list_empty(&amp;intc_desc_list)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Process all controllers with the current &#x27;parent&#x27;.</span></span><br><span class="line"><span class="comment">		 * First pass will be looking for NULL as the parent.</span></span><br><span class="line"><span class="comment">		 * The assumption is that NULL parent means a root controller.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line">			<span class="comment">//最开始的时候parent变量是NULL，确保第一个被处理的是root interrupt controller。在处理完root node之后，parent变量被设定为root interrupt controller，因此，第二个循环中处理的是所有parent是root interrupt controller的child interrupt controller。也就是level 1（如果root是level 0的话）的节点。</span></span><br><span class="line">			<span class="keyword">if</span> (desc-&gt;interrupt_parent != parent)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">			of_node_set_flag(desc-&gt;dev, OF_POPULATED);</span><br><span class="line"></span><br><span class="line">			pr_debug(<span class="string">&quot;of_irq_init: init %pOF (%p), parent %p\n&quot;</span>,</span><br><span class="line">				 desc-&gt;dev,</span><br><span class="line">				 desc-&gt;dev, desc-&gt;interrupt_parent);</span><br><span class="line">			ret = desc-&gt;irq_init_cb(desc-&gt;dev,</span><br><span class="line">						desc-&gt;interrupt_parent);<span class="comment">//执行初始化函数,即gic_of_init</span></span><br><span class="line">			<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">				of_node_clear_flag(desc-&gt;dev, OF_POPULATED);</span><br><span class="line">				kfree(desc);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * This one is now set up; add it to the parent list so</span></span><br><span class="line"><span class="comment">			 * its children can get processed in a subsequent pass.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			list_add_tail(&amp;desc-&gt;<span class="built_in">list</span>, &amp;intc_parent_list);<span class="comment">//处理完的节点放入intc_parent_list链表，后面会用到</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Get the next pending parent that might have children */</span></span><br><span class="line">		desc = list_first_entry_or_null(&amp;intc_parent_list,</span><br><span class="line">						typeof(*desc), <span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (!desc) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;of_irq_init: children remain, but no parents\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);<span class="comment">//每处理完一个节点就会将该节点删除，当所有的节点被删除，整个处理过程也就是结束了</span></span><br><span class="line">		parent = desc-&gt;dev;</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	list_for_each_entry_safe(desc, temp_desc, &amp;intc_parent_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line">err:</span><br><span class="line">	list_for_each_entry_safe(desc, temp_desc, &amp;intc_desc_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		list_del(&amp;desc-&gt;<span class="built_in">list</span>);</span><br><span class="line">		of_node_put(desc-&gt;dev);</span><br><span class="line">		kfree(desc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在machine driver初始化的时候会调用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/of/irq.c#L473">of_irq_init()</a>函数，在该函数中会扫描所有interrupt controller的节点，并调用适合的interrupt controller driver进行初始化，根据里面配置的级联中断信息按顺序做好映射的工作。毫无疑问，初始化需要注意顺序，首先初始化root，然后first level，second level，最后是leaf node。</p>
<h3 id="4-4-gic-of-init"><a href="#4-4-gic-of-init" class="headerlink" title="4.4 gic_of_init()"></a><font size=3>4.4 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/irqchip/irq-gic.c#L1438">gic_of_init()</a></font></h3><p>继续跟踪desc-&gt;irq_init_cb的回调函数<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/drivers/irqchip/irq-gic.c#L1438">gic_of_init()</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">gic_of_init</span><span class="params">(<span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> __iomem *cpu_base;</span><br><span class="line">	<span class="type">void</span> __iomem *dist_base;</span><br><span class="line">	u32 percpu_offset;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line">	dist_base = of_iomap(node, <span class="number">0</span>);<span class="comment">//获取reg地址空间，GIC Distributor的寄存器地址，负责连接系统中所有的中断源</span></span><br><span class="line">	WARN(!dist_base, <span class="string">&quot;unable to map gic dist registers\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cpu_base = of_iomap(node, <span class="number">1</span>);<span class="comment">//获取reg地址空间，GIC CPU interface的寄存器地址，</span></span><br><span class="line">	WARN(!cpu_base, <span class="string">&quot;unable to map gic cpu registers\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gic_cnt == <span class="number">0</span> &amp;&amp; !gic_check_eoimode(node, &amp;cpu_base))</span><br><span class="line">		static_key_slow_dec(&amp;supports_deactivate);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_property_read_u32(node, <span class="string">&quot;cpu-offset&quot;</span>, &amp;percpu_offset))</span><br><span class="line">		percpu_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__gic_init_bases(gic_cnt, <span class="number">-1</span>, dist_base, cpu_base, percpu_offset,</span><br><span class="line">			 &amp;node-&gt;fwnode);<span class="comment">//里面会注册domain</span></span><br><span class="line">	<span class="keyword">if</span> (!gic_cnt)</span><br><span class="line">		gic_init_physaddr(node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent) &#123;<span class="comment">//root GIC不会执行到这里,因为其parent是null</span></span><br><span class="line">		irq = irq_of_parse_and_map(node, <span class="number">0</span>);<span class="comment">//解析second GIC的interrupts属性，并进行mapping，返回IRQ number</span></span><br><span class="line">		gic_cascade_irq(gic_cnt, irq);<span class="comment">//设置handler </span></span><br><span class="line">	&#125;</span><br><span class="line">	gic_cnt++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>值得说明的是，root GIC不会执行执行irq_of_parse_and_map函数，关于irq_of_parse_and_map函数，我们放到后面叙述。</p>
<h2 id="4-5-说明"><a href="#4-5-说明" class="headerlink" title="4.5 说明"></a><font size=3>4.5 说明</font></h2><p>后面的部分有点多，感觉不是现在学习的重点，可以参考下面的文章：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Guet_Kite/article/details/97261350">嵌入式Linux驱动笔记(二十七)——中断子系统框架分析_irq: type mismatch-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/irq_subsystem/irq-domain.html">Linux kernel的中断子系统之（二）：IRQ Domain介绍</a></p>
<p><a target="_blank" rel="noopener" href="http://www.wowotech.net/irq_subsystem/gic_driver.html">linux kernel的中断子系统之（七）：GIC代码分析</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZHONGkunjia/article/details/89735332">Linux中断子系统框架流程详解（基于Kernel 3.16，arm，设备树）_linux 硬件中断详细流程处理视频-CSDN博客</a></p>
</blockquote>
<h1 id="三、Linux-系统对中断的处理"><a href="#三、Linux-系统对中断的处理" class="headerlink" title="三、Linux 系统对中断的处理  "></a><font size=3>三、Linux 系统对中断的处理  </font></h1><h2 id="1-进程、线程、中断的核心：栈"><a href="#1-进程、线程、中断的核心：栈" class="headerlink" title="1. 进程、线程、中断的核心：栈  "></a><font size=3>1. 进程、线程、中断的核心：栈  </font></h2><p>中断谁？中断当前正在运行的进程、线程。进程、线程是什么？内核如何切换进程、线程、中断？要理解这些概念，必须理解栈的作用。</p>
<h3 id="1-1-ARM-处理器程序运行的过程"><a href="#1-1-ARM-处理器程序运行的过程" class="headerlink" title="1.1 ARM 处理器程序运行的过程  "></a><font size=3>1.1 ARM 处理器程序运行的过程  </font></h3><p>ARM 芯片属于精简指令集计算机(RISC： Reduced Instruction Set Computing)，它所用的指令比较简单，有如下特点：① 对内存只有读、写指令；② 对于数据的运算是在 CPU 内部实现；③ 使用 RISC 指令的 CPU 复杂度小一点，易于设计。</p>
<p>比如对于 a&#x3D;a+b 这样的算式，需要经过下面 4 个步骤才可以实现：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214145510571.png" alt="image-20250214145510571" style="zoom: 43%;" />

<p>细看这几个步骤，有些疑问：</p>
<p>① 读 a，那么 a 的值读出来后保存在 CPU 里面哪里？</p>
<p>② 读 b，那么 b 的值读出来后保存在 CPU 里面哪里？</p>
<p>③ a+b 的结果又保存在哪里？</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214145539057.png" alt="image-20250214145539057" style="zoom:43%;" />

<p>我们需要深入 ARM 处理器的内部。简单概括如下，我们先忽略各种 CPU 模式(系统模式、用户模式等等)。 CPU 运行时，先去取得指令，再执行指令：</p>
<p>① 把内存 a 的值读入 CPU 寄存器 R0</p>
<p>② 把内存 b 的值读入 CPU 寄存器 R1</p>
<p>③ 把 R0、 R1 累加，存入 R0</p>
<p>④ 把 R0 的值写入内存 a</p>
<h3 id="1-2-程序被中断时，怎么保存现场"><a href="#1-2-程序被中断时，怎么保存现场" class="headerlink" title="1.2 程序被中断时，怎么保存现场  "></a><font size=3>1.2 程序被中断时，怎么保存现场  </font></h3><p>从上图可知， CPU 内部的寄存器很重要，如果要暂停一个程序，中断一个程序，就需要把这些寄存器的值保存下来：这就称为保存现场。保存在哪里？内存，这块内存就称之为栈。程序要继续执行，就先从栈中恢复那些 CPU 内部寄存器的值。这个场景并不局限于中断，下图可以概括程序 A、 B 的切换过程，其他情况是类似的：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214145810987.png" alt="image-20250214145810987"  />

<ul>
<li>（1）函数调用：</li>
</ul>
<p>在函数 A 里调用函数 B，实际就是中断函数 A 的执行。那么需要把函数 A 调用 B 之前瞬间的 CPU 寄存器的值，保存到栈里；再去执行函数 B；函数 B 返回之后，就从栈中恢复函数 A 对应的 CPU 寄存器值，继续执行。</p>
<ul>
<li>（2）中断处理</li>
</ul>
<p>进程 A 正在执行，这时候发生了中断。CPU 强制跳到中断异常向量地址去执行，这时就需要保存进程 A 被中断瞬间的 CPU 寄存器值，可以保存在进程 A 的内核态栈，也可以保存在进程 A 的内核结构体中。中断处理完毕，要继续运行进程 A 之前，恢复这些值。</p>
<ul>
<li>（3）进程切换</li>
</ul>
<p>在所谓的多任务操作系统中，我们以为多个程序是同时运行的。如果我们能感知微秒、纳秒级的事件，可以发现操作系统时让这些程序依次执行一小段时间，进程 A 的时间用完了，就切换到进程 B。怎么切换？切换过程是发生在内核态里的，跟中断的处理类似。进程 A 的被切换瞬间的 CPU 寄存器值保存在某个地方；恢复进程 B 之前保存的 CPU 寄存器值，这样就可以运行进程 B 了。所以，在中断处理的过程中，伴存着进程的保存现场、恢复现场。 进程的调度也是使用栈来保存、恢复现场：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214150026383.png" alt="image-20250214150026383"  />

<h3 id="1-3-进程、线程的概念"><a href="#1-3-进程、线程的概念" class="headerlink" title="1.3 进程、线程的概念  "></a><font size=3>1.3 进程、线程的概念  </font></h3><p>假设我们写一个音乐播放器，在播放音乐的同时会根据按键选择下一首歌。把事情简化为 2 件事：发送音频数据、读取按键。那可以这样写程序：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key = read_key();</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> NEXT:</span><br><span class="line">                    select_next_music(); <span class="comment">// 在 GUI 选中下一首歌</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            send_music();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序只有一条主线，读按键、播放音乐都是顺序执行。无论按键是否被按下， read_key 函数必须马上返回，否则会使得后续的send_music 受到阻滞导致音乐播放不流畅。  </p>
<p>读取按键、播放音乐能否分为两个程序进行？可以，但是开销太大：读按键的程序，要把按键通知播放音乐的程序，进程间通信的效率没那么高。  </p>
<p>这时可以用多线程之编程，读取按键是一个线程，播放音乐是另一个线程，它们之间可以通过全局变量传递数据，示意代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g_key;</span><br><span class="line"><span class="type">void</span> <span class="title function_">key_thread_fn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_key = read_key();</span><br><span class="line">        <span class="keyword">if</span> (g_key != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (g_key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> NEXT:</span><br><span class="line">                    select_next_music(); <span class="comment">// 在 GUI 选中下一首歌</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">music_fn</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_key == STOP)</span><br><span class="line">            stop_music();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            send_music();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    create_thread(key_thread_fn);</span><br><span class="line">    create_thread(music_fn);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，按键的读取及 GUI 显示、音乐的播放，可以分开来，不必混杂在一起。按键线程可以使用阻塞方式读取按键，无按键时是休眠的，这可以节省 CPU资源。</p>
<p>音乐线程专注于音乐的播放和控制，不用理会按键的具体读取工作。并且这 2 个线程通过全局变量 g_key 传递数据，高效而简单。  </p>
<p>在 Linux 中：<strong>资源分配的单位是进程，调度的单位是线程。</strong>也就是说，在一个进程里，可能有多个线程，这些线程共用打开的文件句柄、全局变量等等。而这些线程，之间是互相独立的，“同时运行”，也就是说：每一个线程，都有自己的栈。如下图示：  </p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214150819673.png" alt="image-20250214150819673" style="zoom:50%;" />

<h2 id="2-Linux-系统对中断处理的演进"><a href="#2-Linux-系统对中断处理的演进" class="headerlink" title="2. Linux 系统对中断处理的演进  "></a><font size=3>2. Linux 系统对中断处理的演进  </font></h2><p>Linux 中断系统的变化并不大。比较重要的就是引入了 threaded irq：使用内核线程来处理中断。Linux 系统中有硬件中断，也有软件中断。中断的执行需要快速响应， 但并不是所有中断都能迅速完成。</p>
<p>此外， Linux 中的中断不支持嵌套， 意味着在正式处理中断之前会屏蔽其他中断， 直到中断处理完成后再重新允许接收中断， 如果中断处理时间过长， 将会引发问题。所以对中断的处理有 2 个原则：不能嵌套，越快越好。   </p>
<h3 id="2-1-Linux-对中断的扩展：硬件中断、软件中断"><a href="#2-1-Linux-对中断的扩展：硬件中断、软件中断" class="headerlink" title="2.1 Linux 对中断的扩展：硬件中断、软件中断  "></a><font size=3>2.1 Linux 对中断的扩展：硬件中断、软件中断  </font></h3><h4 id="2-1-1-硬件中断"><a href="#2-1-1-硬件中断" class="headerlink" title="2.1.1 硬件中断"></a><font size=3>2.1.1 硬件中断</font></h4><p>Linux 系统把中断的意义扩展了，对于按键中断等硬件产生的中断，称之为“硬件中断” (hard irq)。每个硬件中断都有对应的处理函数，比如按键中断、网卡中断的处理函数肯定不一样。  </p>
<p>为方便理解，我们可以先认为对硬件中断的处理是用数组来实现的，数组里存放的是函数指针：  </p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214151722926.png" alt="image-20250214151722926"  />

<p>注意：上图是简化的， Linux 中这个数组复杂多了。当发生 A 中断时，对应的 irq_function_A 函数被调用。硬件导致该函数被调用。</p>
<h4 id="2-1-2-软件中断"><a href="#2-1-2-软件中断" class="headerlink" title="2.1.2 软件中断"></a><font size=3>2.1.2 软件中断</font></h4><p>相对的，还可以人为地制造中断：软件中断(soft irq)，如下图所示：  </p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214151807711.png" alt="image-20250214151807711"  />

<p>注意：上图是简化的， Linux 中这个数组复杂多了。</p>
<p>问题来了：   </p>
<p>（1）软件中断何时生产？  由软件决定，对于 X 号软件中断，只需要把它的 flag 设置为 1 就表示发生了该中断。  </p>
<p>（2）软件中断何时处理？  软件中断嘛，并不是那么十万火急，有空再处理它好了。什么时候有空？不能让它一直等吧？Linux 系统中，各种硬件中断频繁发生，至少定时器中断每 10ms 发生一次，那取个巧？在处理完硬件中断后，再去处理软件中断？就这么办！        </p>
<p>（3）有哪些软件中断？可以看这个文件 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/interrupt.h">interrupt.h - include&#x2F;linux&#x2F;interrupt.h</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HI_SOFTIRQ=<span class="number">0</span>,    <span class="comment">/* 高优先级软中断 */</span></span><br><span class="line">	TIMER_SOFTIRQ,   <span class="comment">/* 定时器软中断 */</span></span><br><span class="line">	NET_TX_SOFTIRQ,  <span class="comment">/* 网络数据发送软中断 */</span></span><br><span class="line">	NET_RX_SOFTIRQ,  <span class="comment">/* 网络数据接收软中断 */</span></span><br><span class="line">	BLOCK_SOFTIRQ,</span><br><span class="line">	IRQ_POLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ, <span class="comment">/* tasklet 软中断 */</span></span><br><span class="line">	SCHED_SOFTIRQ,   <span class="comment">/* 调度软中断 */</span></span><br><span class="line">	HRTIMER_SOFTIRQ, <span class="comment">/* 高精度定时器软中断 Unused, but kept as tools rely on the numbering. Sigh! */</span></span><br><span class="line">	RCU_SOFTIRQ,    <span class="comment">/* RCU 软中断 Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些中断定义在一个数组中：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/softirq.c#L56">softirq_vec</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br></pre></td></tr></table></figure>

<p>可以看出，一共有 10 个软中断，因此 NR_SOFTIRQS 为 10，因此数组 softirq_vec 有 10 个元素。 softirq_action 结构体中的 action 成员变量就是软中断的服务函数，数组 softirq_vec 是个全局数组，因此所有的 CPU(对于 SMP 系统而言)都可以访问到，每个 CPU 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 CPU 所执行的软中断服务函数确是相同的，都是数组 softirq_vec 中定义的 action 函数。  </p>
<p>（4）怎么触发软件中断？最核心的函数是 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/softirq.c#L439">raise_softirq()</a>，简单地理解就是设置 softirq_veq[nr]的标记位：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span>;</span><br></pre></td></tr></table></figure>

<p>其中nr表示要触发的软中断。</p>
<p>（5）怎么设置软件中断的处理函数？可以用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/softirq.c#L454">open_softirq()</a>来设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>;</span><br></pre></td></tr></table></figure>

<p>nr表示要开启的软中断，action表示软中断对应的处理函数。该函数没有返回值。</p>
<blockquote>
<p>后面会学习到中断下半部 tasklet ，它就是使用软件中断实现的。  </p>
</blockquote>
<h3 id="2-2-中断处理原则-1：不能嵌套"><a href="#2-2-中断处理原则-1：不能嵌套" class="headerlink" title="2.2 中断处理原则 1：不能嵌套  "></a><font size=3>2.2 中断处理原则 1：不能嵌套  </font></h3><blockquote>
<p>kernel内核官网资料：<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e58aa3d2d0cc">genirq: Run irq handlers with interrupts disabled - kernel&#x2F;git&#x2F;torvalds&#x2F;linux.git - Linux kernel source tree</a></p>
</blockquote>
<p>中断处理函数需要调用 C 函数，这就需要用到栈。中断 A 正在处理的过程中，假设又发生了中断 B，那么在栈里要保存 A 的现场，然后处理 B。在处理 B 的过程中又发生了中断 C，那么在栈里要保存 B 的现场，然后处理C。</p>
<p>如果中断嵌套突然暴发，那么栈将越来越大，栈终将耗尽。所以，为了防止这种情况发生，也是为了简单化中断的处理，在 Linux 系统上中断无法嵌套：即当前中断 A 没处理完之前，不会响应另一个中断 B(即使它的优先级更高)。    </p>
<h3 id="2-3-中断处理原则-2：越快越好"><a href="#2-3-中断处理原则-2：越快越好" class="headerlink" title="2.3 中断处理原则 2：越快越好  "></a><font size=3>2.3 中断处理原则 2：越快越好  </font></h3><p>还是之前的例子，我们看书的时候，手机响起， 发出紧急电话的铃声， 打破了我们看书的过程，接电话的时间很短并不会对看书产生很大的影响， 而接电话的时候水烧开了的话可能就有问题了， 接电话时间过长的话，水可能会烧干。</p>
<p>同理，在 Linux 系统中，中断的处理也是越快越好。在单芯片系统中，假设中断处理很慢，那应用程序在这段时间内就无法执行：系统显得很迟顿。在 SMP 系统中，假设中断处理很慢，那么正在处理这个中断的 CPU 上的其他线程也无法执行。</p>
<p>在中断的处理过程中，该 CPU 是不能进行进程调度的，所以中断的处理要越快越好，尽早让其他中断能被处理──进程调度靠定时器中断来实现。  在 Linux 系统中使用中断很简单，为某个中断 irq 注册中断处理函数handler，可以使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/interrupt.h#L144">request_irq()</a>函数：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 handler 函数中，代码尽可能高效。但是，处理某个中断要做的事情就是很多，没办法加快。比如对于按键中断，我们需要等待几十毫秒消除机械抖动。难道要在 handler 中等待吗？对于计算机来说，这可是一个段很长的时间。怎么办？</p>
<h4 id="2-3-1-拆分为：上半部、下半部"><a href="#2-3-1-拆分为：上半部、下半部" class="headerlink" title="2.3.1 拆分为：上半部、下半部  "></a><font size=3>2.3.1 拆分为：上半部、下半部  </font></h4><p>当一个中断要耗费很多时间来处理时，它的坏处是：在这段时间内，其他中断无法被处理。换句话说，在这段时间内，系统是关中断的。如果某个中断就是要做那么多事，我们能不能把它拆分成两部分：紧急的、不紧急的？</p>
<p>在 handler 函数里只做紧急的事，然后就重新开中断，让系统得以正常运行；那些不紧急的事，以后再处理，处理时是开中断的。  </p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-01-%E4%B8%AD%E6%96%AD%E5%9F%BA%E7%A1%80/img/image-20250214152941268.png" alt="image-20250214152941268" style="zoom: 33%;" />

<p>所以为了让系统可以更好地处理中断事件， 提高实时性和响应能力， 可以将中断服务程序划分为上半部和下半部两部分，上半部 (<strong>就是中断服务程序</strong>)内核立即执行，而下半部(<strong>就是一些内核函数</strong>)留着稍后处理：</p>
<p>中断上半部是中断服务程序的第一部分， 它主要处理一些紧急且需要快速响应的任务。 中断上半部的特点是执行时间较短， 旨在尽快完成对中断的处理。 这些任务可能包括保存寄存器状态、更新计数器等， 以便在中断处理完成后能够正确地返回到中断前的执行位置。</p>
<p>中断下半部是中断服务程序的第二部分， 它主要处理一些相对耗时的任务。 由于中断上半部需要尽快完成， 因此中断下半部负责处理那些不能立即完成的、 需要更多时间的任务。 这些任务可能包括复杂的计算、 访问外部设备或进行长时间的数据处理等。</p>
<p>至于哪些代码属于上半部，哪些代码属于下半部并没有明确的规定，一切根据实际使用情况去判断。这里有一些可以借鉴的参考点：  </p>
<p>①、如果要处理的内容不希望被其他中断打断，那么可以放到上半部。  </p>
<p>②、如果要处理的任务对时间敏感，可以放到上半部。</p>
<p>③、如果要处理的任务与硬件有关，可以放到上半部</p>
<p>④、除了上述三点以外的其他任务，优先考虑放到下半部。</p>
<h4 id="2-3-2-下半部的实现机制有哪些？"><a href="#2-3-2-下半部的实现机制有哪些？" class="headerlink" title="2.3.2 下半部的实现机制有哪些？"></a><font size=3>2.3.2 下半部的实现机制有哪些？</font></h4><p>一个快速的“上半部”来处理硬件发出的请求，它必须在一个新的中断产生之前终止。通常，除了在设备和一些内存缓冲区(如果设备用到了DMA，就不止这些)之间移动或传送数据，确定硬件是否处于健全的状态之外，这一部分做的工作很少。“下半部”运行时是允许中断请求的，而上半部运行时是关中断的，这是二者之间的主要区别。</p>
<p>内核到底什么时候执行下半部，以何种方式组织下半部？</p>
<p>以前的内核中，下半部的机制叫做bottom-half(以下简称BH)。但是，Linux的这种bottom-half机制有两个缺点：</p>
<p>（1）在任意一时刻，系统只能有一个CPU可以执行BH代码，以防止两个或多个CPU同时来执行BH函数而相互干扰。因此BH代码的执行是严格“串行化”的。</p>
<p>（2）BH函数不允许嵌套。</p>
<p>这两个缺点在单CPU系统中是无关紧要的，但在SMP系统中却是非常致命的。因为BH机制的严格串行化执行显然没有充分利用SMP系统的多CPU特点。为此，在2.4以后的版本中有了新的发展和改进，改进的目标使下半部可以在多处理机上并行执行，并有助于驱动程序的开发者进行驱动程序的开发。目前的内核中，下半部处理机制主要是以下三种：</p>
<table>
    <tr><td align="center" width="400px">Item</td><td align="center">软中断请求(softirq)机制</td><td align="center">小任务(tasklet)机制</td><td align="center">Workqueue工作队列</td></tr>
    <tr><td align="center">运行Context</td><td align="center">软中断</td><td align="center">软中断(HI_SOFTIRQ和TASKLET_SOFTIRQ)</td><td align="center">进程(kernel态)</td></tr>
    <tr><td align="center">可以Sleep？</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr>
    <tr><td align="center">关中断？</td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr>
    <tr><td align="center">可重新调度？</td><td align="center">否</td><td align="center">否</td><td align="center">是</td></tr>
    <tr><td align="center">可带参数？</td><td align="center">否</td><td align="center">是</td><td align="center">否</td></tr>
    <tr><td align="center">谁触发谁执行</td><td align="center">是</td><td align="center">是</td><td align="center">默认是</td></tr>
    <tr><td align="center">可同时被多个CPU执行？</td><td align="center">同一个softirq_action可同时被多CPU执行</td><td align="center">同一个tasklet在任意时刻只能被一个CPU执行</td><td align="center">由进程调度决定</td></tr>
    <tr><td align="center">可延时执行？</td><td align="center">否</td><td align="center">否</td><td align="center">是</td></tr>
    <tr><td align="center">数据结构</td><td align="center">softirq_action(中断服务)<br>irq_cpustat_t(触发状态)</td><td align="center">tasklet_struct<br>tasklet_head</td><td align="center">work_struct<br>workqueue_struct</td></tr>
    <tr><td align="center">初始化</td><td align="center">open_softirq</td><td align="center">DECLARE_TASKLET<br>DECLARE_TASKLET_DISABLED<br>tasklet_init</td><td align="center">DECLARE_WORK<br>INIT_WORK<br>DECLARE_DELAYED_WORK<br>INIT_DELAYED_WORK</td></tr>
    <tr><td align="center">改变运行状态</td><td align="center"> </td><td align="center">tasklet_trylock<br>tasklet_unlock<br>tasklet_unlock_wait</td><td align="center"> </td></tr>
    <tr><td align="center">使能/静止</td><td align="center"> </td><td align="center">tasklet_disable<br>tasklet_enable</td><td align="center"> </td></tr>
    <tr><td align="center">触发</td><td align="center">raise_softirq<br>raise_softirq_irqoff</td><td align="center">tasklet_schedule<br>tasklet_hi_schedule</td><td align="center">schedule_work<br>queue_work<br>schedule_delayed_work<br>queue_delayed_work</td></tr>
    <tr><td align="center">执行</td><td align="center">do_softirq</td><td align="center">tasklet_action<br>tasklet_hi_action</td><td align="center">rescuer_thread被cpu调度执行</td></tr>
    <tr><td align="center">创建线程</td><td align="center"> </td><td align="center"></td><td align="center">alloc_work_queue<br>create_singlethread_workqueue</td></tr>
    <tr><td align="center">结束</td><td align="center"> </td><td align="center">tasklet_kill</td><td align="center">destroy_worker<br>destroy_workqueue</td></tr>
</table>

<p>具体这三种机制，后面再详细学习。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a><font size=3>3. 总结</font></h2><p>中断的处理有两个原则：  </p>
<ul>
<li>不能嵌套</li>
<li>越快越好</li>
</ul>
<p>在处理当前中断时，即使发生了其他中断，其他中断也不会得到处理，所以中断的处理要越快越好。但是某些中断要做的事情稍微耗时，这时可以把中断拆分为上半部、下半部。  </p>
<p>在上半部处理紧急的事情，在上半部的处理过程中，中断是被禁止的；在下半部处理耗时的事情，在下半部的处理过程中，中断是使能的。    </p>
<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Guet_Kite/article/details/97261350">嵌入式Linux驱动笔记(二十七)——中断子系统框架分析_irq: type mismatch-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/myarrow/article/details/9287169">中断处理下半部机制-CSDN博客</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">




    <div>
        
            <div style="text-align:center;color: #ccc;font-size:14px;">
            ----------本文结束
            <i class="fas fa-fan fa-spin" style="color: #FF1493; font-size: 1rem"></i>
            感谢您的阅读----------
            </div>
        
    </div>





  
  <div class="my_post_copyright"> 
    <p><span>文章标题:</span><a href="/post/1551cbe5.html">LV06-13-中断-01-中断基础</a></p>
    <p><span>文章作者:</span><a href="/" title="欢迎访问 《苏木》 的学习笔记">苏木</a></p>
    <p><span>发布时间:</span>2025年03月23日 - 18:41</p>
    <p><span>最后更新:</span>2025年06月14日 - 00:25</p>
    <p><span>原始链接:</span><a href="/post/1551cbe5.html" title="LV06-13-中断-01-中断基础">https://sumumm.github.io/post/1551cbe5.html</a></p>
    <p><span>许可协议:</span><i class="fab fa-creative-commons"></i> <a rel="license" href= "https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
  </div>
  


          <div class="post-tags">
              <a href="/tags/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" rel="tag"><i class="fa fa-tag"></i> LV06-驱动开发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/f0ec804f.html" rel="prev" title="LV06-13-中断-02-中断的申请流程">
                  <i class="fa fa-angle-left"></i> LV06-13-中断-02-中断的申请流程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/72a70fb1.html" rel="next" title="LV06-13-中断-03-中断下半部-02-工作队列">
                  LV06-13-中断-03-中断下半部-02-工作队列 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">苏木</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.7m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">225:26</span>
  </span>
</div>




    <span id="sitetime"></span>
    <script defer language=javascript>
        function siteTime()
        {
            window.setTimeout("siteTime()", 1000);
            var seconds = 1000;
            var minutes = seconds * 60;
            var hours = minutes * 60;
            var days = hours * 24;
            var years = days * 365;
            var today = new Date();
            var todayYear = today.getFullYear();
            var todayMonth = today.getMonth()+1;
            var todayDate = today.getDate();
            var todayHour = today.getHours();
            var todayMinute = today.getMinutes();
            var todaySecond = today.getSeconds();
            /*==================================================
            Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
            year        - 作为date对象的年份，为4位年份值
            month       - 0-11之间的整数，做为date对象的月份
            day         - 1-31之间的整数，做为date对象的天数
            hours       - 0(午夜24点)-23之间的整数，做为date对象的小时数
            minutes     - 0-59之间的整数，做为date对象的分钟数
            seconds     - 0-59之间的整数，做为date对象的秒数
            microseconds - 0-999之间的整数，做为date对象的毫秒数
            ==================================================*/
            var t1 = Date.UTC(2017, 
                              5, 
                              19, 
                              0, 
                              0, 
                              0); //北京时间
            var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
            var diff = t2-t1;
            var diffYears = Math.floor(diff/years);
            var diffDays = Math.floor((diff/days)-diffYears*365);
            var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
            var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
            var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
            document.getElementById("sitetime").innerHTML="已在这里 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
        }
        siteTime();
    </script>



    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


 
        <div id="click-show-text"
            data-mobile = false
            data-text = 富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善
            data-fontsize = 15px
            data-random= false>
        </div>
       

      
        <script async src=https://cdn.jsdelivr.net/npm/hexo-next-mouse-effect@latest/click/showText.js></script>
      

      
    




    <script async src="/js/fancybox_param.js"></script>





<!-- APlayer本体 -->



</body>
</html>
