<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/green/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"sumumm.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":300},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="工作队列是什么？若笔记中有错误或者不合适的地方，欢迎批评指正😃。">
<meta property="og:type" content="article">
<meta property="og:title" content="LV06-13-中断-03-中断下半部-02-工作队列">
<meta property="og:url" content="https://sumumm.github.io/post/72a70fb1.html">
<meta property="og:site_name" content="苏木">
<meta property="og:description" content="工作队列是什么？若笔记中有错误或者不合适的地方，欢迎批评指正😃。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322094204703.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322095959293.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323124243669.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323124431349.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323125809743.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323125926666.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323163256690.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322132412435.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322132434049.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322132616413.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323130632382.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323130738788.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323155624505.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323155652793.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322140047828.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322140117291.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322140231580.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322140631939.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323161027223.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322142749855.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322142840493.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322144032880.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322144627197.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323163609657.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323163709969.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323163844304.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323164045263.png">
<meta property="article:published_time" content="2025-03-23T10:40:42.000Z">
<meta property="article:modified_time" content="2025-06-13T16:25:57.056Z">
<meta property="article:author" content="苏木">
<meta property="article:tag" content="LV06-驱动开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322094204703.png">


<link rel="canonical" href="https://sumumm.github.io/post/72a70fb1.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"https://sumumm.github.io/post/72a70fb1.html","path":"post/72a70fb1.html","title":"LV06-13-中断-03-中断下半部-02-工作队列"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LV06-13-中断-03-中断下半部-02-工作队列 | 苏木</title>
  








    <script src="/js/browser_tools_disable.js"></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.com/hexo-next-tags-plus@latest/lib/tag_plus.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">苏木</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我的学习之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>苏木的家</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类页<span class="badge">42</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档页<span class="badge">673</span></a></li><li class="menu-item menu-item-flink"><a href="/flink/" rel="section"><i class="fa fa-link fa-fw"></i>友人帐</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B"><span class="nav-text">一、工作队列简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1. 工作队列是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">2. 基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">3. 工作队列的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%80%8E%E4%B9%88%E6%8F%8F%E8%BF%B0%EF%BC%9F"><span class="nav-text">4. 怎么描述？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%B7%A5%E4%BD%9C"><span class="nav-text">4.1 工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">4.2 工作队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B"><span class="nav-text">4.3 工作者线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E6%80%BB%E7%BB%93"><span class="nav-text">4.4. 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%85%B1%E4%BA%AB%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">二、共享工作队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%9B%B8%E5%85%B3%E7%9A%84api"><span class="nav-text">1. 相关的api</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-text">1.1 初始化函数  </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%EF%BC%9AINIT-WORK"><span class="nav-text">1.1.1 动态创建工作：INIT_WORK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-%E9%9D%99%E6%80%81%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%EF%BC%9ADECLARE-WORK"><span class="nav-text">1.1.2 静态创建工作：DECLARE_WORK</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%B0%83%E5%BA%A6-%E5%8F%96%E6%B6%88%E8%B0%83%E5%BA%A6"><span class="nav-text">1.2 调度&#x2F;取消调度  </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-schedule-work"><span class="nav-text">1.2.1 schedule_work()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-cancel-work-sync"><span class="nav-text">1.2.2 cancel_work_sync()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%82%E8%80%83%E7%A4%BA%E4%BE%8B"><span class="nav-text">2. 参考示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%85%B1%E4%BA%AB%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97demo"><span class="nav-text">3. 共享工作队列demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-demo%E6%BA%90%E7%A0%81"><span class="nav-text">3.1 demo源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%BC%80%E5%8F%91%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="nav-text">3.2 开发板测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">三、自定义工作队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1. 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%B7%A5%E4%BD%9C"><span class="nav-text">1.1 工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">1.2 工作队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%9B%B8%E5%85%B3%E7%9A%84api"><span class="nav-text">2. 相关的api</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">2.1 创建工作队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-create-workqueue"><span class="nav-text">2.1.1 create_workqueue()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-create-singlethread-workqueue"><span class="nav-text">2.1.2 create_singlethread_workqueue()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E8%B0%83%E5%BA%A6-%E5%8F%96%E6%B6%88%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">2.2 调度&#x2F;取消工作队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-queue-work-on"><span class="nav-text">2.2.1 queue_work_on()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-cancel-work-sync"><span class="nav-text">2.2.2 cancel_work_sync()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%88%B7%E6%96%B0%E5%B7%A5%E4%BD%9C%E9%A1%B9"><span class="nav-text">2.3 刷新工作项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E5%88%A0%E9%99%A4%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">2.4 删除工作队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97demo"><span class="nav-text">3. 自定义工作队列demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-demo%E6%BA%90%E7%A0%81-1"><span class="nav-text">3.1 demo源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%BC%80%E5%8F%91%E6%9D%BF%E6%B5%8B%E8%AF%95-1"><span class="nav-text">3.2 开发板测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C"><span class="nav-text">四、延迟工作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C%E7%AE%80%E4%BB%8B"><span class="nav-text">1. 延迟工作简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%AE%80%E4%BB%8B"><span class="nav-text">1.1 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">1.2 应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">2. 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-struct-delayed-work"><span class="nav-text">2.1 struct delayed_work</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%9B%B8%E5%85%B3%E7%9A%84api"><span class="nav-text">3. 相关的api</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-text">3.1 初始化延迟工作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-DECLARE-DELAYED-WORK"><span class="nav-text">3.1.1 DECLARE_DELAYED_WORK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-INIT-DELAYED-WORK"><span class="nav-text">3.1.2 INIT_DELAYED_WORK</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E8%B0%83%E5%BA%A6-%E5%8F%96%E6%B6%88%E8%B0%83%E5%BA%A6"><span class="nav-text">3.2 调度&#x2F;取消调度   </span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-schedule-delayed-work"><span class="nav-text">3.2.1 schedule_delayed_work()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-queue-delayed-work"><span class="nav-text">3.2.2 queue_delayed_work()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-cancel-delayed-work-sync"><span class="nav-text">3.2.3 cancel_delayed_work_sync()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9Cdemo"><span class="nav-text">4. 延迟工作demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-demo%E6%BA%90%E7%A0%81"><span class="nav-text">4.1 demo源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%BC%80%E5%8F%91%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="nav-text">4.2 开发板测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E4%BC%A0%E5%8F%82"><span class="nav-text">五、工作队列传参</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%80%9A%E8%BF%87%E5%B7%A5%E4%BD%9C%E9%A1%B9"><span class="nav-text">1. 通过工作项 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E4%BC%A0%E5%8F%82demo"><span class="nav-text">2. 工作队列传参demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-demo%E6%BA%90%E7%A0%81"><span class="nav-text">2.1 demo源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%BC%80%E5%8F%91%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="nav-text">2.2 开发板测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%B9%B6%E5%8F%91%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-text">六、并发管理工作队列  </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">1. 工作队列的实现  </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-workqueue-%E9%98%9F%E5%88%97%E5%BC%8A%E7%AB%AF"><span class="nav-text">2. workqueue 队列弊端  </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-text">3. 什么是并发管理工作队列？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%9B%B8%E5%85%B3%E7%9A%84api"><span class="nav-text">4. 相关的api</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-alloc-workqueue"><span class="nav-text">4.1 alloc_workqueue()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%B9%B6%E5%8F%91%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97demo"><span class="nav-text">5. 并发管理工作队列demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-demo%E6%BA%90%E7%A0%81"><span class="nav-text">5.1 demo源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%BC%80%E5%8F%91%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="nav-text">5.2 开发板测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96"><span class="nav-text">七、中断线程化  </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-%EF%BC%9F"><span class="nav-text">1. 什么是中断线程化 ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%9B%B8%E5%85%B3%E7%9A%84api-1"><span class="nav-text">2. 相关的api</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-request-threaded-irq"><span class="nav-text">2.1 request_threaded_irq()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-free-irq"><span class="nav-text">2.2 free_irq()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="nav-text">2.3 简单示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-request-threaded-irq-%E6%9C%BA%E5%88%B6"><span class="nav-text">3. request_threaded_irq()机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB"><span class="nav-text">3.1 数据结构关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-request-threaded-irq-%E5%87%BD%E6%95%B0"><span class="nav-text">3.2 request_threaded_irq()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-setup-irq"><span class="nav-text">3.2.1 __setup_irq()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-setup-irq-thread"><span class="nav-text">3.2.2 setup_irq_thread()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E4%B8%AD%E6%96%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">3.3 中断的执行过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96demo"><span class="nav-text">4. 中断线程化demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-demo%E6%BA%90%E7%A0%81-1"><span class="nav-text">4.1 demo源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%BC%80%E5%8F%91%E6%9D%BF%E6%B5%8B%E8%AF%95-1"><span class="nav-text">4.2 开发板测试</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苏木"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">苏木</p>
  <div class="site-description" itemprop="description">莫道桑榆晚，为霞尚满天</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">673</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sumumm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sumumm" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sumumm.github.io/post/72a70fb1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="苏木">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏木">
      <meta itemprop="description" content="莫道桑榆晚，为霞尚满天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LV06-13-中断-03-中断下半部-02-工作队列 | 苏木">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LV06-13-中断-03-中断下半部-02-工作队列
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-23 18:40:42" itemprop="dateCreated datePublished" datetime="2025-03-23T18:40:42+08:00">2025-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">嵌入式开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/" itemprop="url" rel="index"><span itemprop="name">02IMX6ULL平台</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">LV06-驱动开发</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>53 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>工作队列是什么？若笔记中有错误或者不合适的地方，欢迎批评指正😃。</p>
<span id="more"></span>

<!-- Photo: https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/ -->

<details class="folding-tag" blue><summary> 点击查看使用工具及版本 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center" rowspan="5">PC端开发环境</td>        <td align="center" width=150px>Windows</td>        <td align="left">Windows11</td>    </tr>    <tr>        <td align="center">Ubuntu</td>        <td align="left">Ubuntu20.04.2的64位版本</td>      </tr>    <tr>        <td align="center">VMware® Workstation 17 Pro</td>        <td align="left">17.6.0 build-24238078</td>      </tr>    <tr>        <td align="center">终端软件</td>        <td align="left">MobaXterm(Professional Edition v23.0 Build 5042 (license))</td>    </tr>    <tr>        <td align="center">Win32DiskImager</td>        <td align="left">Win32DiskImager v1.0</td>      </tr>    <tr>        <td align="center" rowspan="3">Linux开发板环境</td>        <td align="center">Linux开发板</td>        <td align="left">正点原子 i.MX6ULL Linux 阿尔法开发板</td>      </tr>    <tr>        <td align="center">uboot</td>        <td align="left">NXP官方提供的uboot，使用的uboot版本为U-Boot 2019.04</td>      </tr>    <tr>        <td align="center">linux内核</td>        <td align="left">linux-4.19.71(NXP官方提供)</td>      </tr></table>
              </div>
            </details>

<details class="folding-tag" blue><summary> 点击查看本文参考资料 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center">分类</td>        <td align="center">网址</td>        <td align="center">说明</td>    </tr>    <tr>        <td align="center" rowspan="5">官方网站</td>        <td align="left"><a href="https://www.arm.com/" target="_blank">https://www.arm.com/</a></td>        <td align="left">ARM官方网站，在这里我们可以找到Cotex-Mx以及ARMVx的一些文档</td>    </tr>    <tr>        <td align="left"><a href="https://www.nxp.com.cn/" target="_blank">https://www.nxp.com.cn/ </a></td>        <td align="left">NXP官方网站</td>    </tr>    <tr>        <td align="left"><a href="https://www.nxpic.org.cn/" target="_blank">https://www.nxpic.org.cn/</a></td><td align="left">NXP 官方社区</td>    </tr>    <tr>        <td align="left"><a href="https://u-boot.readthedocs.io/en/latest/" target="_blank">https://u-boot.readthedocs.io/en/latest/</a></td><td align="left">u-boot官网</td>    </tr>    <tr>        <td align="left"><a href="https://www.kernel.org/" target="_blank">https://www.kernel.org/</a></td><td align="left">linux内核官网</td>    </tr></table>
              </div>
            </details>

<details class="folding-tag" blue><summary> 点击查看相关文件下载 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center">分类</td>        <td align="center">网址</td>        <td align="center">说明</td>    </tr>    <tr>        <td align="center" rowspan="3">NXP</td>        <td align="left"><a href="https://github.com/nxp-imx" target="_blank">https://github.com/nxp-imx</a></td>        <td align="left">NXP imx开发资源GitHub组织，里边会有u-boot和linux内核的仓库</td>    </tr>    <tr>        <td align="left"><a href="https://github.com/nxp-imx/linux-imx/releases/tag/v4.19.71" target="_blank">nxp-imx/linux-imx/releases/tag/v4.19.71</a></td>        <td align="left">NXP linux内核仓库tags中的v4.19.71</td>    </tr>    <tr>        <td align="left"><a href="https://github.com/nxp-imx/uboot-imx/releases/tag/rel_imx_4.19.35_1.1.0" target="_blank">nxp-imx/uboot-imx/releases/tag/rel_imx_4.19.35_1.1.0</a></td>        <td align="left">NXP u-boot仓库tags中的rel_imx_4.19.35_1.1.0</td>    </tr>    <tr>        <td align="center" rowspan="2">I.MX6ULL</td>        <td align="left"><a href="https://www.nxp.com.cn/docs/en/data-sheet/IMX6ULLIEC.pdf" target="_blank">i.MX 6ULL Applications Processors for Industrial Products</a></td>        <td align="left">I.MX6ULL 芯片手册（datasheet，可以在线查看）</td>    </tr>    <tr>        <td align="left"><a href="https://www.nxp.com.cn/webapp/Download?colCode=IMX6ULLRM&lang_cd=zh" target="_blank">i.MX 6ULL Applications ProcessorReference Manual</a></td>        <td align="left">I.MX6ULL 参考手册（下载后才能查看，需要登录NXP官网）</td>    </tr>    <tr>        <td align="center" rowspan="3">Source Code</td>        <td align="left"><a href="https://elixir.bootlin.com/linux/latest/source" target="_blank">https://elixir.bootlin.com/linux/latest/source</a></td>        <td align="left">linux kernel源码</td>    </tr>    <tr>        <td align="left"><a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/?h=v4.19.71&id=e7d2672c66e4d3675570369bf20856296da312c4" target="_blank">kernel/git/stable/linux.git - Linux kernel stable tree</a></td>        <td align="left">linux kernel源码(官网,tag 4.19.71)</td>    </tr>    <tr>        <td align="left"><a href="https://elixir.bootlin.com/u-boot/latest/source" target="_blank">https://elixir.bootlin.com/u-boot/latest/source</a></td>        <td align="left">uboot源码</td>    </tr></table>
              </div>
            </details>

<h1 id="一、工作队列简介"><a href="#一、工作队列简介" class="headerlink" title="一、工作队列简介"></a><font size=3>一、工作队列简介</font></h1><p>在中断下半部的执行过程中，虽然是开中断的，期间可以处理各类中断。但是毕竟整个中断的处理还没走完，这期间 APP 是无法执行的。假设下半部要执行 1、 2 分钟，在这 1、 2 分钟里 APP 都是无法响应的。  </p>
<p>这谁受得了？所以，如果中断要做的事情实在太耗时，那就不能用软件中断来做，而应该用内核线程来做：在中断上半部唤醒内核线程。内核线程和 APP 都一样竞争执行， APP 有机会执行，系统不会卡顿。这个内核线程是系统帮我们创建的，一般是 kworker 线程，内核中有很多这样的线程：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A | grep kworker</span><br></pre></td></tr></table></figure>

<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322094204703.png" alt="image-20250322094204703"  />

<p>总的来说，下半部要做的事情太多并且很复杂，我们就可以考虑使用工作队列。接下来就来了解一下吧。  </p>
<h2 id="1-工作队列是什么？"><a href="#1-工作队列是什么？" class="headerlink" title="1. 工作队列是什么？"></a><font size=3>1. 工作队列是什么？</font></h2><p>工作队列是实现中断下半部分的机制之一， 是一种用于管理任务的数据结构或机制。 它通常用于多线程， 多进程或分布式系统中， 用于协调和分配待处理的任务给可用的工作线程或工作进程。  </p>
<p>工作队列（work queue）是另外一种将工作推后执行的形式，它和前面讨论的tasklet有所不同。工作队列可以把工作推后，交由一个内核线程去执行，也就是说，这个下半部分可以在进程上下文中执行。这样，通过工作队列执行的代码能占尽进程上下文的所有优势。最重要的就是<strong>工作队列允许被重新调度甚至是睡眠。</strong></p>
<p>那么，什么情况下使用工作队列，什么情况下使用tasklet。<strong>如果推后执行的任务需要睡眠，那么就选择工作队列；如果推后执行的任务不需要睡眠，那么就选择tasklet</strong>。另外，<strong>如果需要用一个可以重新调度的实体来执行我们的下半部处理，也应该使用工作队列</strong>。它是唯一能在进程上下文运行的下半部实现的机制，也只有它才可以睡眠。这意味着在需要获得大量的内存时、在需要获取信号量时，在需要执行阻塞式的I&#x2F;O操作时，它都会非常有用。如果不需要用一个内核线程来推后执行工作，那么就考虑使用tasklet。</p>
<p>但是多个工作(函数)是在某个内核线程中依序执行的，前面函数执行很慢，就会影响到后面的函数。在多 CPU 的系统下，一个工作队列可以有多个内核线程，可以在一定程度上缓解这个问题。 </p>
<h2 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2. 基本原理"></a><font size=3>2. 基本原理</font></h2><p>工作队列的基本原理是将需要执行的任务按顺序排列在队列中， 并提供一组工作线程或者工作进程来处理队列中的任务。 当有新的任务到达时， 它们会被添加到队列的末尾， 工作线程或工作进程从队列的头部获取任务， 并执行相应的处理操作。  </p>
<p>工作队列将工作推后以后， 会交给内核线程去执行。 Linux 在启动过程中会创建一个工作者内核线程， 这个线程创建以后处于 sleep 状态。 当有工作需要处理的时候， 会唤醒这个线程去处理工作。 </p>
<p>在内核中，我们并不需要自己去创建线程，可以使用“ 工作队列 ” (workqueue)。内核初始化工作队列时，就为它创建了内核线程。以后我们要使用“工作队列”，只需要把“工作”放入“工作队列中”，对应的内核线程就会取出“工作”，执行里面的函数。</p>
<p>在 2.xx 的内核中，工作队列的内部机制比较简单；在现在 4.x 的内核中，工作队列的内部机制做得复杂无比，但是用法是一样的。</p>
<h2 id="3-工作队列的类型"><a href="#3-工作队列的类型" class="headerlink" title="3. 工作队列的类型"></a><font size=3>3. 工作队列的类型</font></h2><p>在内核中， 工作队列包括共享工作队列和自定义工作队列这两种类型。 这两种类型的工作队列具有不同的特点和用途。  </p>
<ul>
<li>共享队列是由内核管理的全局工作队列， 用于处理内核中一些系统级任务。 共享工作队列是内核中一个默认工作队列， 可以由多个内核组件和驱动程序共享使用。</li>
<li>自定义工作队列是由内核或驱动程序创建的特定工作队列， 用于处理特定的任务。 自定义工作队列通常与特定的内核模块或驱动程序相关联， 用于执行该模块或驱动程序相关的任务。</li>
</ul>
<h2 id="4-怎么描述？"><a href="#4-怎么描述？" class="headerlink" title="4. 怎么描述？"></a><font size=3>4. 怎么描述？</font></h2><h3 id="4-1-工作"><a href="#4-1-工作" class="headerlink" title="4.1 工作"></a><font size=3>4.1 工作</font></h3><p>我们把推后执行的任务叫做工作（work），在 Linux 内核中， 使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L102">work_struct</a> 结构体表示一个工作项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">// 连接所有工作的链表</span></span><br><span class="line">	<span class="type">work_func_t</span> func;       <span class="comment">// 要执行的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些结构被连接成链表。当一个工作者线程被唤醒时，它会执行它的链表上的所有工作。工作被执行完毕，它就将相应的 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L102">work_struct</a> 对象从链表上移去。当链表上不再有对象的时候，它就会继续休眠。</p>
<h3 id="4-2-工作队列"><a href="#4-2-工作队列" class="headerlink" title="4.2 工作队列"></a><font size=3>4.2 工作队列</font></h3><p>上面说的工作以队列结构组织成工作队列（workqueue），工作队列使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L237">workqueue_struct</a> 结构体表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs</span>;</span>		<span class="comment">/* WR: all pwqs of this wq */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span>		<span class="comment">/* PR: list of all workqueues */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-工作者线程"><a href="#4-3-工作者线程" class="headerlink" title="4.3 工作者线程"></a><font size=3>4.3 工作者线程</font></h3><p>工作有了，工作队列有了，那谁来处理工作？Linux 内核使用工作者线程(worker thread)来处理工作队列中的各个工作，使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue_internal.h#L24">struct worker</a> 结构体表示工作者线程  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> &#123;</span></span><br><span class="line">	<span class="comment">/* on idle list while idle, on busy hash table while busy */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span>	<span class="comment">/* L: while idle */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">hentry</span>;</span>	<span class="comment">/* L: while busy */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">	<span class="comment">/* used only by rescuers to point to the target workqueue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span>	*<span class="title">rescue_wq</span>;</span>	<span class="comment">/* I: the workqueue to rescue */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个 worker 都有一个工作队列，工作者线程处理自己工作队列中的所有工作。</p>
<h3 id="4-4-总结"><a href="#4-4-总结" class="headerlink" title="4.4. 总结"></a><font size=3>4.4. 总结</font></h3><p>在实际的驱动开发中，我们只需要定义工作(work_struct)即可，关于工作队列和工作者线程我们基本不用去管。如下图，流水线相当于工作队列， 流水线上一个个等待处理的物料相当于一个个工作。 机器相当于内核线程或进程。    </p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322095959293.png" alt="image-20250322095959293"  />

<h1 id="二、共享工作队列"><a href="#二、共享工作队列" class="headerlink" title="二、共享工作队列"></a><font size=3>二、共享工作队列</font></h1><h2 id="1-相关的api"><a href="#1-相关的api" class="headerlink" title="1. 相关的api"></a><font size=3>1. 相关的api</font></h2><h3 id="1-1-初始化函数"><a href="#1-1-初始化函数" class="headerlink" title="1.1 初始化函数  "></a><font size=3>1.1 初始化函数  </font></h3><h4 id="1-1-1-动态创建工作：INIT-WORK"><a href="#1-1-1-动态创建工作：INIT-WORK" class="headerlink" title="1.1.1 动态创建工作：INIT_WORK"></a><font size=3>1.1.1 动态创建工作：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L249">INIT_WORK</a></font></h4><p>在实际的驱动开发中， 我们只需要定义工作项(<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L102">work_struct</a>)即可， 关于工作队列和工作者线程我们基本不用去管。 简单创建工作很简单， 直接定义一个 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L102">work_struct</a> 结构体变量即可，然后使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L249">INIT_WORK</a> 宏来初始化工作， <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L249">INIT_WORK</a> 宏定义如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INIT_WORK(_work, _func, _onstack)				\</span></span><br><span class="line"><span class="meta">	do &#123;								\</span></span><br><span class="line"><span class="meta">		static struct lock_class_key __key;			\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">		__init_work((_work), _onstack);				\</span></span><br><span class="line"><span class="meta">		(_work)-&gt;data = (atomic_long_t) WORK_DATA_INIT();	\</span></span><br><span class="line"><span class="meta">		lockdep_init_map(&amp;(_work)-&gt;lockdep_map, <span class="string">&quot;(work_completion)&quot;</span>#_work, &amp;__key, 0); \</span></span><br><span class="line"><span class="meta">		INIT_LIST_HEAD(&amp;(_work)-&gt;entry);			\</span></span><br><span class="line"><span class="meta">		(_work)-&gt;func = (_func);				\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_WORK(_work, _func)						\</span></span><br><span class="line"><span class="meta">	__INIT_WORK((_work), (_func), 0)</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L249">INIT_WORK</a> 宏接受两个参数： _work 和 _func， 分别表示要初始化的工作项和工作项的处理函数。示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cfg80211_scan_done(<span class="keyword">struct</span> work_struct *wk)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfg80211_registered_device</span> *<span class="title">rdev</span>;</span></span><br><span class="line"> </span><br><span class="line">	rdev = container_of(wk, <span class="keyword">struct</span> cfg80211_registered_device,</span><br><span class="line">			    scan_done_wk);</span><br><span class="line"> </span><br><span class="line">	cfg80211_lock_rdev(rdev);</span><br><span class="line">	___cfg80211_scan_done(rdev, <span class="literal">false</span>);</span><br><span class="line">	cfg80211_unlock_rdev(rdev);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfg80211_registered_device</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">scan_done_wk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">sched_scan_results_wk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">conn_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">event_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cfg80211_wowlan</span> *<span class="title">wowlan</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfg80211_registered_device</span> *<span class="title">rdev</span>;</span></span><br><span class="line">rdev = kzalloc(alloc_size, GFP_KERNEL);</span><br><span class="line"> </span><br><span class="line">INIT_WORK(&amp;rdev-&gt;scan_done_wk, __cfg80211_scan_done);  <span class="comment">// 其执行函数为： __cfg80211_scan_done</span></span><br><span class="line">INIT_WORK(&amp;rdev-&gt;sched_scan_results_wk, __cfg80211_sched_scan_results);</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-静态创建工作：DECLARE-WORK"><a href="#1-1-2-静态创建工作：DECLARE-WORK" class="headerlink" title="1.1.2 静态创建工作：DECLARE_WORK"></a><font size=3>1.1.2 静态创建工作：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L197">DECLARE_WORK</a></font></h4><p>也可以使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L197">DECLARE_WORK</a> 宏在编译时静态地完成工作的创建和初始化， 宏定义如下：    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __WORK_INITIALIZER(n, f) &#123;					\</span></span><br><span class="line"><span class="meta">	.data = WORK_DATA_STATIC_INIT(),				\</span></span><br><span class="line"><span class="meta">	.entry	= &#123; &amp;(n).entry, &amp;(n).entry &#125;,				\</span></span><br><span class="line"><span class="meta">	.func = (f),							\</span></span><br><span class="line"><span class="meta">	__WORK_INIT_LOCKDEP_MAP(#n, &amp;(n))				\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WORK(n, f)						\</span></span><br><span class="line"><span class="meta">	struct work_struct n = __WORK_INITIALIZER(n, f)</span></span><br></pre></td></tr></table></figure>

<p>参数 n 表示定义的工作(work_struct)， f 表示工作对应的处理函数。简单示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_poweroff</span><span class="params">(<span class="keyword">struct</span> work_struct *dummy)</span></span><br><span class="line">&#123;</span><br><span class="line">	kernel_power_off();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WORK</span><span class="params">(poweroff_work, do_poweroff)</span>;</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个全局静态变量：static work_struct poweroff_work，且被初始化了，其执行函数为do_poweroff()。</p>
<h3 id="1-2-调度-取消调度"><a href="#1-2-调度-取消调度" class="headerlink" title="1.2 调度&#x2F;取消调度  "></a><font size=3>1.2 调度&#x2F;取消调度  </font></h3><h4 id="1-2-1-schedule-work"><a href="#1-2-1-schedule-work" class="headerlink" title="1.2.1 schedule_work()"></a><font size=3>1.2.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L557">schedule_work()</a></font></h4><p>和 tasklet 一样， 工作也是需要调度才能运行的， 工作的调度函数为 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L557">schedule_work()</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。 这个函数作用是将工作项提交到工作队列中， 并请求调度器在合适的时机执行工作项，该函数会返回一个布尔值， 表示工作项是否成功被提交到工作队列。</p>
<p>这个函数会把 work 提供给系统默认的 work queue： <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L338">system_wq</a>，它是一个队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">system_wq</span> __<span class="title">read_mostly</span>;</span></span><br><span class="line">EXPORT_SYMBOL(system_wq);</span><br></pre></td></tr></table></figure>

<p>谁来执行 work 中的函数？<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L557">schedule_work()</a> 函数不仅仅是把 work 放入队列，还会把kworker 线程唤醒。此线程抢到时间运行时，它就会从队列中取出 work，执行里面的函数。</p>
<blockquote>
<p>Tips：把work放入工作队列，work马上就会被调度，一旦其所在的处理器上的工作者线程被唤醒，它就会被执行。 </p>
</blockquote>
<h4 id="1-2-2-cancel-work-sync"><a href="#1-2-2-cancel-work-sync" class="headerlink" title="1.2.2 cancel_work_sync()"></a><font size=3>1.2.2 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L3023">cancel_work_sync()</a></font></h4><p>如果想要取消工作项的调度，可以使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L3023">cancel_work_sync()</a> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cancel_work_sync</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __cancel_work_timer(work, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(cancel_work_sync);</span><br></pre></td></tr></table></figure>

<p>参数是指向工作项的指针。 这个函数的作用是取消该工作项的调度。 如果工作项已经在工作队列中， 它将被从队列中移除。 如果工作项已经在工作队列中， 它将被从队列中移除， 并等待工作项执行完成。 函数返回一个布尔值， 表示工作项是否成功取消。  </p>
<h2 id="2-参考示例"><a href="#2-参考示例" class="headerlink" title="2. 参考示例"></a><font size=3>2. 参考示例</font></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义工作(work) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">testwork</span>;</span></span><br><span class="line"><span class="comment">/* work 处理函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testwork_func_t</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* work 具体处理内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">	<span class="comment">/* 调度 work */</span></span><br><span class="line">	schedule_work(&amp;testwork);</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    <span class="comment">/* 初始化 work */</span></span><br><span class="line">    INIT_WORK(&amp;testwork, <span class="type">testwork_func_t</span>);</span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    request_irq(xxx_irq, test_handler, <span class="number">0</span>, <span class="string">&quot;xxx&quot;</span>, &amp;xxx_dev);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-共享工作队列demo"><a href="#3-共享工作队列demo" class="headerlink" title="3. 共享工作队列demo"></a><font size=3>3. 共享工作队列demo</font></h2><h3 id="3-1-demo源码"><a href="#3-1-demo源码" class="headerlink" title="3.1 demo源码"></a><font size=3>3.1 demo源码</font></h3><p>源码可以看这里：<a target="_blank" rel="noopener" href="https://gitee.com/sumumm/imx6ull-driver-demo/tree/master/13_interrupt/07_nodts_workqueue_share">13_interrupt&#x2F;07_nodts_workqueue_share · 苏木&#x2F;imx6ull-driver-demo - 码云 - 开源中国</a></p>
<h3 id="3-2-开发板测试"><a href="#3-2-开发板测试" class="headerlink" title="3.2 开发板测试"></a><font size=3>3.2 开发板测试</font></h3><p>拷贝驱动到开发板中，加载驱动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod sdriver_demo.ko</span><br></pre></td></tr></table></figure>

<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323124243669.png" alt="image-20250323124243669" />

<p>然后按下按键再释放，就会触发按键中断，按键中断中会提交一个工作项到工作队列，在工作队列的处理函数中，延时了1s：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323124431349.png" alt="image-20250323124431349" />

<p>下面的两次是在工作队列的处理函数未执行完的时候又按了一次。大概也都是间隔了1s。</p>
<h1 id="三、自定义工作队列"><a href="#三、自定义工作队列" class="headerlink" title="三、自定义工作队列"></a><font size=3>三、自定义工作队列</font></h1><p>共享队列是由内核管理的全局工作队列， 自定义工作队列是由内核或驱动程序创建的特定工作队列， 用于处理特定的任务。接下来就来学习一下自定义工作队列吧。</p>
<h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a><font size=3>1. 数据结构</font></h2><h3 id="1-1-工作"><a href="#1-1-工作" class="headerlink" title="1.1 工作"></a><font size=3>1.1 工作</font></h3><p>在 Linux 内核中， 使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L102">work_struct</a> 结构体表示一个工作项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span> data;     <span class="comment">// 工作项的数据字段</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">// 工作项在工作队列中的链表节点</span></span><br><span class="line">	<span class="type">work_func_t</span> func;       <span class="comment">// 工作项的处理函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span><span class="comment">// 锁依赖性映射</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些结构被连接成链表。当一个工作者线程被唤醒时，它会执行它的链表上的所有工作。工作被执行完毕，它就将相应的 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L102">work_struct</a> 对象从链表上移去。当链表上不再有对象的时候，它就会继续休眠。</p>
<h3 id="1-2-工作队列"><a href="#1-2-工作队列" class="headerlink" title="1.2 工作队列"></a><font size=3>1.2 工作队列</font></h3><p>工作以队列结构组织成工作队列（workqueue），工作队列使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L237">workqueue_struct</a> 结构体表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs</span>;</span>		<span class="comment">/* WR: all pwqs of this wq */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span>		<span class="comment">/* PR: list of all workqueues */</span></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-相关的api"><a href="#2-相关的api" class="headerlink" title="2. 相关的api"></a><font size=3>2. 相关的api</font></h2><h3 id="2-1-创建工作队列"><a href="#2-1-创建工作队列" class="headerlink" title="2.1 创建工作队列"></a><font size=3>2.1 创建工作队列</font></h3><h4 id="2-1-1-create-workqueue"><a href="#2-1-1-create-workqueue" class="headerlink" title="2.1.1 create_workqueue()"></a><font size=3>2.1.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L448">create_workqueue()</a></font></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_workqueue(fmt, flags, max_active, args...)		\</span></span><br><span class="line"><span class="meta">(&#123;									\</span></span><br><span class="line"><span class="meta">	static struct lock_class_key __key;				\</span></span><br><span class="line"><span class="meta">	const char *__lock_name;					\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	__lock_name = <span class="string">&quot;(wq_completion)&quot;</span>#fmt#args;			\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	__alloc_workqueue_key((fmt), (flags), (max_active),		\</span></span><br><span class="line"><span class="meta">			      &amp;__key, __lock_name, ##args);		\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> create_workqueue(name)						\</span></span><br><span class="line"><span class="meta">	alloc_workqueue(<span class="string">&quot;%s&quot;</span>, __WQ_LEGACY | WQ_MEM_RECLAIM, 1, (name))</span></span><br></pre></td></tr></table></figure>

<p>参数 name 是创建的工作队列的名字。使用这个函数可以给每个 CPU 都创建一个 CPU 相关的工作队列。这是一个宏，传入的是名字，我们怎么得到返回值？返回值是什么样的？我们展开看一下，可以看到最后是调用了<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L4050">__alloc_workqueue_key()</a>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *__<span class="title">alloc_workqueue_key</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">fmt</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">int</span> <span class="title">max_active</span>,</span></span><br><span class="line"><span class="class">					       <span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">const</span> <span class="title">char</span> *<span class="title">lock_name</span>, ...)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    	<span class="keyword">return</span> wq;</span><br><span class="line"></span><br><span class="line">err_free_wq:</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">err_destroy:</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__alloc_workqueue_key);</span><br></pre></td></tr></table></figure>

<p>这个函数创建成功返回一个 struct workqueue_struct 类型指针， 创建失败返回 NULL。  </p>
<h4 id="2-1-2-create-singlethread-workqueue"><a href="#2-1-2-create-singlethread-workqueue" class="headerlink" title="2.1.2 create_singlethread_workqueue()"></a><font size=3>2.1.2 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L453">create_singlethread_workqueue()</a></font></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> create_singlethread_workqueue(name)				\</span></span><br><span class="line"><span class="meta">	alloc_ordered_workqueue(<span class="string">&quot;%s&quot;</span>, __WQ_LEGACY | WQ_MEM_RECLAIM, name)</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L453">create_singlethread_workqueue()</a>函数只会给一个 CPU 创建一个 CPU 相关的工作队列。参数 name 是创建的工作队列的名字。 使用这个函数只会给一个 CPU 创建一个 CPU 相关的工作队列。 创建成功之后返回一个 struct workqueue_struct 类型指针， 创建失败返回 NULL。  </p>
<h3 id="2-2-调度-取消工作队列"><a href="#2-2-调度-取消工作队列" class="headerlink" title="2.2 调度&#x2F;取消工作队列"></a><font size=3>2.2 调度&#x2F;取消工作队列</font></h3><h4 id="2-2-1-queue-work-on"><a href="#2-2-1-queue-work-on" class="headerlink" title="2.2.1 queue_work_on()"></a><font size=3>2.2.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L1466">queue_work_on()</a></font></h4><p>当工作队列创建好之后， 需要将要延迟执行的工作项放在工作队列上， 调度工作队列，可以使用<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L1466">queue_work_on()</a>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">queue_work_on</span><span class="params">(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">		   <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) &#123;</span><br><span class="line">		__queue_work(cpu, wq, work);</span><br><span class="line">		ret = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(queue_work_on);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L1466">queue_work_on()</a>函数还有其他变种， 比如 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L499">queue_work()</a> 函数， 这里略过， 其实思路是一致的， 用于将定义好的工作项立即添加到工作队列中， 并在工作队列可用时立即执行。</p>
<p>该函数有三个参数， 第一个参数是一个整数 cpu， 第二个参数是一个指向 struct workqueue_struct 的指针 wq， 第三个参数是一个指向 struct work_struct 的指针 work。</p>
<p>该函数的返回类型是布尔值， 表示是否成功调度工作队列。 </p>
<h4 id="2-2-2-cancel-work-sync"><a href="#2-2-2-cancel-work-sync" class="headerlink" title="2.2.2 cancel_work_sync()"></a><font size=3>2.2.2 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L3023">cancel_work_sync()</a></font></h4><p>如果要取消一个已经调度的工作， 使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L3023">cancel_work_sync()</a> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cancel_work_sync</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __cancel_work_timer(work, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(cancel_work_sync);</span><br></pre></td></tr></table></figure>

<p>函数的作用是取消一个已经调度的工作， 如果被取消的工作已经正在执行， 则会等待他执行完成再返回。</p>
<h3 id="2-3-刷新工作项"><a href="#2-3-刷新工作项" class="headerlink" title="2.3 刷新工作项"></a><font size=3>2.3 刷新工作项</font></h3><p>在 Linux 内核中，使用  <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L2636">flush_workqueue()</a> 函数将刷新该工作队列中所有已提交但未执行的工作项。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_workqueue</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(flush_workqueue);</span><br></pre></td></tr></table></figure>

<p>该函数参数是一个指向 struct workqueue_struct 类型的指针 wq。 函数的作用是刷新工作队列， 告诉内核尽快处理工作队列上的工作。</p>
<h3 id="2-4-删除工作队列"><a href="#2-4-删除工作队列" class="headerlink" title="2.4 删除工作队列"></a><font size=3>2.4 删除工作队列</font></h3><p>如果要删除自定义的工作队列， 使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L4152">destroy_workqueue()</a> 函数 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destroy_workqueue</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(destroy_workqueue);</span><br></pre></td></tr></table></figure>

<p>该函数参数是一个指向 struct workqueue_struct 类型的指针 wq。  </p>
<h2 id="3-自定义工作队列demo"><a href="#3-自定义工作队列demo" class="headerlink" title="3. 自定义工作队列demo"></a><font size=3>3. 自定义工作队列demo</font></h2><h3 id="3-1-demo源码-1"><a href="#3-1-demo源码-1" class="headerlink" title="3.1 demo源码"></a><font size=3>3.1 demo源码</font></h3><p>demo源码可以看这里：<a target="_blank" rel="noopener" href="https://gitee.com/sumumm/imx6ull-driver-demo/tree/master/13_interrupt/08_nodts_workqueue_custom">13_interrupt&#x2F;08_nodts_workqueue_custom · 苏木&#x2F;imx6ull-driver-demo - 码云 - 开源中国</a></p>
<h3 id="3-2-开发板测试-1"><a href="#3-2-开发板测试-1" class="headerlink" title="3.2 开发板测试"></a><font size=3>3.2 开发板测试</font></h3><p>我们拷贝驱动到开发板中，加载驱动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod sdriver_demo.ko</span><br></pre></td></tr></table></figure>

<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323125809743.png" alt="image-20250323125809743" />

<p>然后按下按键，再抬起，可以看到如下打印信息：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323125926666.png" alt="image-20250323125926666" />

<p>我们还可以看到一条线程，名为 custom_workqueue ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -T # 我用的开发板文件系统不需要-T参数也能查看线程情况</span><br></pre></td></tr></table></figure>

<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323163256690.png" alt="image-20250323163256690" />

<h1 id="四、延迟工作"><a href="#四、延迟工作" class="headerlink" title="四、延迟工作"></a><font size=3>四、延迟工作</font></h1><p>前面我们学习了共享工作队列和自定义工作队列， 为了更形象地理解学习，将流水线比作工作队列， 流水线上一个个等待处理的物料比作一个个工作。 机器比作内核线程或进程。 在这里要学习的延迟工作， 可以类比为将物料延迟一定时间， 再放到生产线上加工。 延迟工作不仅可以在自定义工作队列中实现 也可以在共享工作队列上实现。 现在， 我们对延迟工作有了一个感性的认识， 接下来详细的学习下延迟工作吧。  </p>
<h2 id="1-延迟工作简介"><a href="#1-延迟工作简介" class="headerlink" title="1. 延迟工作简介"></a><font size=3>1. 延迟工作简介</font></h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a><font size=3>1.1 简介</font></h3><p>延迟工作是一种将工作的执行延迟到稍后时间点进行处理的技术。 通常情况下， 当某个任务需要花费较长时间， 不需要立即执行或需要按时执行时， 延迟工作就会派上用场。  </p>
<p>延迟工作的基本思想是将任务放入一个队列中， 然后由后台的工作进程会任务调度程序来处理队列中的任务。 任务可以在指定的延迟时间后执行， 也可以根据优先级， 任务类型或者其他条件进行排序和处理。  </p>
<h3 id="1-2-应用场景"><a href="#1-2-应用场景" class="headerlink" title="1.2 应用场景"></a><font size=3>1.2 应用场景</font></h3><p>延迟工作在许多应用场景中都非常有用， 尤其是在需要处理大量任务， 提供系统性能和可靠性的情况下。 以下是一些常用的应用场景：  </p>
<p>（1）延迟工作常用于处理那些需要花费较长时间的任务， 比如发送电子邮件， 处理图像等。通过将这些任务放入队列中并延迟执行， 可以避免阻塞应用程序的主线程， 提高系统的响应速度。</p>
<p>（2）延迟工作可以用来执行定时任务， 比如定时备份数据库， 通过将任务设置为在未来的某个时间点执行， 提高系统的可靠性和效率。  </p>
<p>比如说开发板上的按键， 现在我们想通过驱动程序读取按键的状态， 那么只需要读取这个按键所连接的 GPIO 的状态就可以了。理想型的按键电压变化过程如图 ：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322132412435.png" alt="image-20250322132412435" style="zoom:50%;" />

<p>在上图中， 按键没有按下的时候按键值为 1， 当按键在 t1 时刻按键被按下以后按键值就变为 0， 这是最理想的状态。 但是实际的按键是机械结构， 加上刚按下去的一瞬间人手可能也有抖动， 实际的按键电压变化过程如下图 :</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322132434049.png" alt="image-20250322132434049" style="zoom:47%;" />

<p>在上图中， t1 时刻按键被按下， 但是由于抖动的原因， 直到 t2 时刻才稳定下来， t1 到t2 这段时间就是抖动。 一般这段时间就是十几 ms 左右， 从上图中可以看出在抖动期间会有多次触发， 如果不消除这段抖动的话软件就会误判， 本来按键就按下了一次， 结果软件读取 IO值发现电平多次跳变以为按下了多次。  </p>
<p>所以我们需要跳过这段抖动时间再去读取按键的 IO 值，也就是至少要在 t2 时刻以后再去读 IO 值。我们可以使用内核定时器来实现消抖。 按键采用中断驱动方式， 当按键按下以后触发按键中断， 在按键中断中开启一个定时器，定时周期为 10ms， 当定时时间到了以后就会触发定时器中断， 最后在定时器中断处理函数中读取按键的值， 如果按键值还是按下状态那就表示这是一次有效的按键。定时器按键消抖如下图 ：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322132616413.png" alt="image-20250322132616413" style="zoom:54%;" />

<p>在上图中 t1~t3 这一段时间就是按键抖动， 是需要消除的。 设置按键为下降沿触发， 因此会在 t1、 t2 和 t3 这三个时刻会触发按键中断， 每次进入中断处理函数都会重新开器定时器中断， 所以会在 t1、 t2 和 t3 这三个时刻开器定时器中断。 但是 t1~t2 和 t2~t3 这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间， 比如 10ms)， 所以虽然 t1 开启了定时器， 但是定时器定时时间还没到呢 t2 时刻就重置了定时器， 最终只有 t3 时刻开启的定时器能完整的完成整个定时周期并触发中断， 我们就可以在中断处理函数里面做按键处理了， 这就是定时器实现按键防抖的原理， Linux 里面的按键驱动用的就是这个原理！  </p>
<p>除了使用定时器方式进行消抖， 也可以使用这里要学习的延迟工作。  </p>
<h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a><font size=3>2. 数据结构</font></h2><h3 id="2-1-struct-delayed-work"><a href="#2-1-struct-delayed-work" class="headerlink" title="2.1 struct delayed_work"></a><font size=3>2.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L115">struct delayed_work</a></font></h3><p>在 Linux 内核中， 使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L115">struct delayed_work</a> 来描述延迟工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span> <span class="comment">// 延迟工作的基本工作结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span> <span class="comment">// 定时器， 用于延迟执行工作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* target workqueue and CPU -&gt;timer uses to queue -&gt;work */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>work： 这是一个 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L102">struct work_struct</a> 类型的成员， 用于表示延迟工作的基本工作结构。 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L102">struct work_struct</a> 是表示工作的常见数据结构， 用于定义要执行的工作内容。</li>
<li>timer： 这是一个 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/timer.h#L11">struct timer_list</a> 类型的成员， 用于管理延迟工作的定时器。 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/timer.h#L11">struct timer_list</a> 是 Linux 内核中的定时器结构， 用于设置延迟时间和触发工作执行的时机。</li>
</ul>
<p>使用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L115">struct delayed_work</a> 结构体， 可以将需要执行的工作封装成一个延迟工作， 并使用定时器来控制工作的延迟执行。 通过设置定时器的延迟时间， 可以指定工作在一定时间后执行。  </p>
<h2 id="3-相关的api"><a href="#3-相关的api" class="headerlink" title="3. 相关的api"></a><font size=3>3. 相关的api</font></h2><h3 id="3-1-初始化延迟工作函数"><a href="#3-1-初始化延迟工作函数" class="headerlink" title="3.1 初始化延迟工作函数"></a><font size=3>3.1 初始化延迟工作函数</font></h3><h4 id="3-1-1-DECLARE-DELAYED-WORK"><a href="#3-1-1-DECLARE-DELAYED-WORK" class="headerlink" title="3.1.1 DECLARE_DELAYED_WORK"></a><font size=3>3.1.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L200">DECLARE_DELAYED_WORK</a></font></h4><p>静态定义并初始化延迟工作使用宏 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L200">DECLARE_DELAYED_WORK</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAYED_WORK_INITIALIZER(n, f, tflags) &#123;			\</span></span><br><span class="line"><span class="meta">	.work = __WORK_INITIALIZER((n).work, (f)),			\</span></span><br><span class="line"><span class="meta">	.timer = __TIMER_INITIALIZER(delayed_work_timer_fn,\</span></span><br><span class="line"><span class="meta">				     (tflags) | TIMER_IRQSAFE),		\</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_DELAYED_WORK(n, f)					\</span></span><br><span class="line"><span class="meta">	struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, 0)</span></span><br></pre></td></tr></table></figure>

<p>n 代表延迟工作的变量名， f 是延迟工作的处理函数。  </p>
<h4 id="3-1-2-INIT-DELAYED-WORK"><a href="#3-1-2-INIT-DELAYED-WORK" class="headerlink" title="3.1.2 INIT_DELAYED_WORK"></a><font size=3>3.1.2 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L271">INIT_DELAYED_WORK</a></font></h4><p>动态定义并初始化延迟工作使用宏 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L271">INIT_DELAYED_WORK</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __INIT_DELAYED_WORK(_work, _func, _tflags)			\</span></span><br><span class="line"><span class="meta">	do &#123;								\</span></span><br><span class="line"><span class="meta">		INIT_WORK(&amp;(_work)-&gt;work, (_func));			\</span></span><br><span class="line"><span class="meta">		__init_timer(&amp;(_work)-&gt;timer,				\</span></span><br><span class="line"><span class="meta">			     delayed_work_timer_fn,			\</span></span><br><span class="line"><span class="meta">			     (_tflags) | TIMER_IRQSAFE);		\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_DELAYED_WORK(_work, _func)					\</span></span><br><span class="line"><span class="meta">	__INIT_DELAYED_WORK(_work, _func, 0)</span></span><br></pre></td></tr></table></figure>

<p>n 代表延迟工作的变量名， f 是延迟工作的处理函数。  </p>
<h3 id="3-2-调度-取消调度"><a href="#3-2-调度-取消调度" class="headerlink" title="3.2 调度&#x2F;取消调度   "></a><font size=3>3.2 调度&#x2F;取消调度   </font></h3><h4 id="3-2-1-schedule-delayed-work"><a href="#3-2-1-schedule-delayed-work" class="headerlink" title="3.2.1 schedule_delayed_work()"></a><font size=3>3.2.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L617">schedule_delayed_work()</a></font></h4><p>在<strong>共享工作队列上调度延迟工作</strong>， 使用函数  <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L617">schedule_delayed_work()</a> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_delayed_work</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork,</span></span><br><span class="line"><span class="params">					 <span class="type">unsigned</span> <span class="type">long</span> delay)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_delayed_work(system_wq, dwork, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数， 用于在给定的延迟时间后调度延迟工作执行。</p>
<p><strong>函数参数</strong>：</p>
<ul>
<li>dwork：是指向延迟工作的指针， 即要被调度的延迟工作。</li>
<li>delay：表示延迟的时间长度， 以内核时钟节拍数 jiffies 为单位。</li>
</ul>
<h4 id="3-2-2-queue-delayed-work"><a href="#3-2-2-queue-delayed-work" class="headerlink" title="3.2.2 queue_delayed_work()"></a><font size=3>3.2.2 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L515">queue_delayed_work()</a></font></h4><p>在<strong>自定义工作队列上调度延迟工作</strong>，使用函数<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L515">queue_delayed_work()</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">queue_delayed_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> delayed_work *dwork,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> <span class="type">long</span> delay)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_delayed_work_on(WORK_CPU_UNBOUND, wq, dwork, delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数是一个内联函数， 用于将延迟工作加入工作队列后在指定的延迟时间后执行。</p>
<p><strong>函数参数</strong> ：</p>
<ul>
<li>wq：是指向工作队列结构的指针， 即要将延迟工作加入的目标工作队列。</li>
<li>dwork：指向延迟工作的指针， 也就是要被加入工作队列的延迟工作。</li>
<li>delay：表示延迟的时间长度， 以内核时钟节拍数 jiffies 为单位。</li>
</ul>
<h4 id="3-2-3-cancel-delayed-work-sync"><a href="#3-2-3-cancel-delayed-work-sync" class="headerlink" title="3.2.3 cancel_delayed_work_sync()"></a><font size=3>3.2.3 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L3128">cancel_delayed_work_sync()</a></font></h4><p>取消延迟工作调度可以用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/workqueue.c#L3128">cancel_delayed_work_sync()</a>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cancel_delayed_work_sync</span><span class="params">(<span class="keyword">struct</span> delayed_work *dwork)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __cancel_work_timer(&amp;dwork-&gt;work, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(cancel_delayed_work_sync);</span><br></pre></td></tr></table></figure>

<p>该函数是一个外部声明的函数， 用于取消延迟工作并等待其完成。   </p>
<p><strong>函数参数</strong>：</p>
<ul>
<li>dwork：指向延迟工作的指针， 也就是要被取消的延迟工作。</li>
</ul>
<p><strong>返回值</strong>：返回 true， 说明成功取消延迟工作并等待其完成。 返回 false， 说明无法取消延迟工作或等待其完成。  </p>
<h2 id="4-延迟工作demo"><a href="#4-延迟工作demo" class="headerlink" title="4. 延迟工作demo"></a><font size=3>4. 延迟工作demo</font></h2><h3 id="4-1-demo源码"><a href="#4-1-demo源码" class="headerlink" title="4.1 demo源码"></a><font size=3>4.1 demo源码</font></h3><p>demo源码可以看这里：<a target="_blank" rel="noopener" href="https://gitee.com/sumumm/imx6ull-driver-demo/tree/master/13_interrupt/09_nodts_workqueue_custom_delay">13_interrupt&#x2F;09_nodts_workqueue_custom_delay · 苏木&#x2F;imx6ull-driver-demo - 码云 - 开源中国</a></p>
<h3 id="4-2-开发板测试"><a href="#4-2-开发板测试" class="headerlink" title="4.2 开发板测试"></a><font size=3>4.2 开发板测试</font></h3><p>我们拷贝驱动到开发板中，加载驱动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod sdriver_demo.ko</span><br></pre></td></tr></table></figure>

<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323130632382.png" alt="image-20250323130632382" />

<p>然后按下按键再抬起，可以看到如下打印信息:</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323130738788.png" alt="image-20250323130738788" />

<p>上面的测试是按了一次，延迟3秒后执行工作，工作中又延迟1s，所以一共是4s。下面是连按了两次，会发现只执行了一次工作处理函数。这是因为我们都是同一个硬件中断，上半部肯定会执行2次，但是下半部有可能只执行一次，在软中断那节的笔记中有提到。</p>
<h1 id="五、工作队列传参"><a href="#五、工作队列传参" class="headerlink" title="五、工作队列传参"></a><font size=3>五、工作队列传参</font></h1><p>前面学习的 tasklet 可以给中断下文传参， 如果我们使用工作队列来实现中断的下半部分， 那么如何用工作队列给中断下文传参呢？  </p>
<h2 id="1-通过工作项"><a href="#1-通过工作项" class="headerlink" title="1. 通过工作项 "></a><font size=3>1. 通过工作项 </font></h2><p>在 Linux 内核的工作队列中， 可以通过使用工作项的方式向工作队列传递参数。 工作项是一个抽象的结构， 可以用于封装需要执行的工作及其相关的参数。  </p>
<ul>
<li>（1）首先我们定义工作项结构</li>
</ul>
<p>如下所示， 在结构体 struct work_data 中定义了需要传递给工作项处理函数的参数 a 和 b， 然后定义一个类型为 struct work_data 的变量 test_workqueue_work。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">test_work</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_data</span> <span class="title">test_workqueue_work</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>（2）接下来在模块初始化函数 interrupt_irq_init 中创建了一个工作队列 test_workqueue 和一个工作项 test_workqueue_work。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_workqueue = create_workqueue(<span class="string">&quot;test_workqueue&quot;</span>);  <span class="comment">// 创建工作队列</span></span><br><span class="line">INIT_WORK(&amp;test_workqueue_work.test_work, test_work); <span class="comment">// 初始化工作项</span></span><br></pre></td></tr></table></figure>

<ul>
<li>（3）然后在模块初始化函数中， 为工作项的参数 a 和 b 赋值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test_workqueue_work.a = <span class="number">1</span>;</span><br><span class="line">test_workqueue_work.b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>（4）当中断触发时， 在中断处理函数 test_interrupt 中， 通过调用 queue_work 函数将工作项test_workqueue_work.test_work 提交到工作队列 test_workqueue 中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue_work(test_workqueue, &amp;test_workqueue_work.test_work);</span><br></pre></td></tr></table></figure>

<ul>
<li>（5）然后工作项处理函数 test_work 定义了一个指针 pdata， 将工作项转换为 struct work_data结构， 并通过该结构访问参数 a 和 b。 如下所示：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line">    pdata = container_of(work, <span class="keyword">struct</span> work_data, test_work);</span><br><span class="line">    printk(<span class="string">&quot;a is %d\n&quot;</span>, pdata-&gt;a);</span><br><span class="line">    printk(<span class="string">&quot;b is %d\n&quot;</span>, pdata-&gt;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样， 当工作队列被调度执行时， 工作项处理函数 test_work 将能够访问到传递给工作项的参数 a 和 b,并在内核日志中打印他们的值。  </p>
<blockquote>
<p>Tips：注意， 工作项处理函数中的 container_of 宏用于从工作项结构的指针获取整个 struct work_data 结构的指针。 这样可以通过指针偏移来访问工作项结构中的其他字段， 例如参数 a和 b。  </p>
</blockquote>
<h2 id="2-工作队列传参demo"><a href="#2-工作队列传参demo" class="headerlink" title="2. 工作队列传参demo"></a><font size=3>2. 工作队列传参demo</font></h2><h3 id="2-1-demo源码"><a href="#2-1-demo源码" class="headerlink" title="2.1 demo源码"></a><font size=3>2.1 demo源码</font></h3><p>demo源码可以看这里：<a target="_blank" rel="noopener" href="https://gitee.com/sumumm/imx6ull-driver-demo/tree/master/13_interrupt/10_nodts_workqueue_custom_param">13_interrupt&#x2F;10_nodts_workqueue_custom_param · 苏木&#x2F;imx6ull-driver-demo - 码云 - 开源中国</a></p>
<h3 id="2-2-开发板测试"><a href="#2-2-开发板测试" class="headerlink" title="2.2 开发板测试"></a><font size=3>2.2 开发板测试</font></h3><p>我们拷贝驱动到开发板中，加载驱动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod sdriver_demo.ko</span><br></pre></td></tr></table></figure>

<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323155624505.png" alt="image-20250323155624505" />

<p>然后按下按键再抬起，可以看到如下打印信息:</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323155652793.png" alt="image-20250323155652793" />

<p>我这里是这样赋值的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p_chrdev-&gt;irq_key.key_work.a = p_chrdev-&gt;irq_key.gpio;</span><br><span class="line">p_chrdev-&gt;irq_key.key_work.b = p_chrdev-&gt;irq_key.irq_num;</span><br></pre></td></tr></table></figure>

<p>所以打印出来的就是gpio引脚号和中断号。</p>
<h1 id="六、并发管理工作队列"><a href="#六、并发管理工作队列" class="headerlink" title="六、并发管理工作队列  "></a><font size=3>六、并发管理工作队列  </font></h1><p>在现代的软件开发中， 我们常常面临着需要同时处理多个任务的挑战。 这些任务可能是并行的、 独立的， 或者需要以某种顺序进行处理。 为了高效地管理这些并发任务， 我们需要一种有效的机制来协调它们的执行。 这就是并发管理工作队列发挥作用的地方。</p>
<h2 id="1-工作队列的实现"><a href="#1-工作队列的实现" class="headerlink" title="1. 工作队列的实现  "></a><font size=3>1. 工作队列的实现  </font></h2><p>前面，我们学习了共享工作队列和自定义工作队列， 在使用工作队列时，我们首先定义一个work结构体， 然后将work添加到workqueue(工作队列)中， 最后worker thread执行 workqueue。 当工作队列中有新 work 产生时， 工作线程（worker thread） 会执行工作队列中每个 work。 当执行完结束的时候， worker thread 会睡眠， 等到新的中断产生， work 再继续添加到工作队列， 然后工作线程执行每个工作， 周而复始。  </p>
<p>在单核线程的系统中， 通常会为每个 CPU（核心） 初始化一个工作线程并关联一个工作队列。 这种默认设置确保每个 CPU 都有一个专门的线程来处理与其绑定的工作队列上的工作项。 如下图 ：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322140047828.png" alt="image-20250322140047828" style="zoom: 40%;" />

<p>在多核线程系统中， 工作队列的设计与单核线程系统有所不同。 在多核线程系统中， 通常会存在多个工作队列， 每个工作队列与一个工作线程（Worker Thread） 绑定。 这样可以充分利用多个核心的并行处理能力。 如下图 :</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322140117291.png" alt="image-20250322140117291" style="zoom:45%;" />

<p>当有新的工作项产生时， 系统需要决定将其分配给哪个工作队列。 一种常见的策略是使用负载均衡算法， 根据工作队列的负载情况来平衡分配工作项， 以避免某个工作队列过载而导致性能下降。 每个工作队列独立管理自己的工作项。 当有新的工作项添加到工作队列时， 工作线程会从其关联的工作队列中获取待执行的工作项， 并执行相应的处理函数。 在多核线程系统中，多个工作线程可以同时执行各自绑定的工作队列中的工作项。 这样可以实现并行处理， 提高系统的整体性能和响应速度。  </p>
<h2 id="2-workqueue-队列弊端"><a href="#2-workqueue-队列弊端" class="headerlink" title="2. workqueue 队列弊端  "></a><font size=3>2. workqueue 队列弊端  </font></h2><p>了解了工作队列是如何实现的， 接下来我们看看传统的工作队列有什么弊端呢？假如说有三个 work 放到了同一个工作队列上， 接下来 CPU 会启动工作线程去执行这三个work， 如下图 ：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322140231580.png" alt="image-20250322140231580" style="zoom:50%;" />

<p>在上图中， 工作项 w0、 w1、 w2 被排队到同一个 CPU 上的绑定工作队列上。 w0 工作项执行的时候， 先工作 5 毫秒， 然后休眠 10 毫秒， 然后CPU再工作 5 毫秒， 然后完成。 工作项 w1 和 w2 都是工作 5ms， 然后休眠 10 ms， 然后完成。 传统工作队列的弊端如下所示：  </p>
<p>（1）在工作项 w0 工作甚至是睡眠时， 工作项 w1 w2 是排队等待的， 在繁忙的系统中， 工作队列可能会积累大量的待处理工作项， 导致任务调度的延迟， 这可能会影响系统的响应性能，并增加工作项的处理时间。  </p>
<p>（2）在工作队列中， 不同的工作项可能具有不同的处理时间和资源需求。 如果工作项的处理时间差异很大， 一些工作线程可能会一直忙于处理长时间的工作项， 而其他工作线程则处于空闲状态， 导致资源利用不均衡。  </p>
<p>（3）在多线程环境下， 多个工作线程同时访问和修改工作队列可能会导致竞争条件的发生。为了确保数据的一致性和正确性， 需要采用适当的同步机制， 如锁或原子操作， 来保护共享数据， 但这可能会引入额外的同步开销。  </p>
<p>（4）工作队列通常按照先进先出（FIFO） 的方式处理工作项， 缺乏对工作项优先级的细粒度控制。 在某些场景下， 可能需要根据工作项的重要性或紧急程度进行优先级调度， 而工作队列本身无法提供这种级别的优先级控制。  </p>
<p>（5）当工作线程从工作队列中获取工作项并执行时， 可能需要频繁地进行上下文切换， 将处理器的执行上下文从一个线程切换到另一个线程。 这种上下文切换开销可能会影响系统的性能和效率。  </p>
<h2 id="3-什么是并发管理工作队列？"><a href="#3-什么是并发管理工作队列？" class="headerlink" title="3. 什么是并发管理工作队列？"></a><font size=3>3. 什么是并发管理工作队列？</font></h2><p>通过上面的了解，我们认识到传统的工作队列无论是单核系统还是多核系统上都是有缺陷的。 比如无法充分利用多核处理器的计算能力以及对于不同优先级的工作项无法提供公平的调度。 为了解决这些问题， Con Kolivas 提出了 CMWQ 调度算法。  </p>
<p>CMWQ 全称是 concurrency Managed Workqueue， 意为并发管理工作队列。 并发管理工作队列是一种并发编程模式， 用于有效地管理和调度待执行的任务或工作项。 它通常用于多线程或多进程环境中， 以实现并发执行和提高系统的性能。 CMWQ 工作实现如下图 ：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322140631939.png" alt="image-20250322140631939"  />

<p>当我们需要在一个系统中同时处理多个任务或工作时， 使用并发管理工作队列是一种有效的方式。  </p>
<p>想象一下， 我们是一个餐厅的服务员， 有很多顾客同时来到餐厅用餐。 为了提高效率， 我们需要将顾客的点菜请求放到一个队列中， 这就是工作队列。 然后， 我们和其他服务员可以从队列中获取顾客的点菜请求， 每个服务员独立地为顾客提供服务。 通过这种方式， 我们可以并发地处理多个顾客的点菜请求， 而不需要等待上一个顾客点完菜再去处理下一个顾客的请求。 每个服务员可以独立地从队列中获取任务， 并根据需要执行相应的服务。 这种独立获取任务的过程就是从工作队列中取出任务并执行的过程。  </p>
<p>通过并发管理工作队列， 我们能够更高效地处理顾客的点菜请求， 提高服务的速度和质量。同时， 这种方式也能够更好地利用我们的工作能力， 因为每个服务员都可以独立处理任务， 而不会相互干扰或等待。  </p>
<p>总的来说， 通过并发管理工作队列， 我们可以同时处理多个任务或工作， 提高系统的并发性和性能。 每个任务独立地从队列中获取并执行， 这种解耦使得整个系统更加高效、 灵活， 并且能够更好地应对多任务的需求。  </p>
<h2 id="4-相关的api"><a href="#4-相关的api" class="headerlink" title="4. 相关的api"></a><font size=3>4. 相关的api</font></h2><h3 id="4-1-alloc-workqueue"><a href="#4-1-alloc-workqueue" class="headerlink" title="4.1 alloc_workqueue()"></a><font size=3>4.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L415">alloc_workqueue()</a></font></h3><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/include/linux/workqueue.h#L415">alloc_workqueue()</a> 是 Linux 内核中的一个函数， 用于创建和分配一个工作队列。 工作队列是一种用于管理和调度工作项的机制， 可用于实现并发处理和异步任务处理。   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_workqueue(fmt, flags, max_active, args...)		\</span></span><br><span class="line"><span class="meta">(&#123;									\</span></span><br><span class="line"><span class="meta">	static struct lock_class_key __key;				\</span></span><br><span class="line"><span class="meta">	const char *__lock_name;					\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	__lock_name = <span class="string">&quot;(wq_completion)&quot;</span>#fmt#args;			\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">	__alloc_workqueue_key((fmt), (flags), (max_active),		\</span></span><br><span class="line"><span class="meta">			      &amp;__key, __lock_name, ##args);		\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_workqueue(fmt, flags, max_active, args...)		\</span></span><br><span class="line"><span class="meta">	__alloc_workqueue_key((fmt), (flags), (max_active),		\</span></span><br><span class="line"><span class="meta">			      NULL, NULL, ##args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li>fmt： 指定工作队列的名称格式。</li>
<li>flags： 指定工作队列的标志， 可以控制工作队列的行为和属性， 如 WQ_UNBOUND 表示无绑定的工作队列， WQ_HIGHPRI 表示高优先级的工作队列等。</li>
<li>max_active： 指定工作队列中同时活跃的最大工作项数量。</li>
</ul>
<p><strong>返回值</strong>：返回一个指向工作队列结构体（struct workqueue_struct） 的指针， 或者返回 NULL 表示创建失败。  </p>
<h2 id="5-并发管理工作队列demo"><a href="#5-并发管理工作队列demo" class="headerlink" title="5. 并发管理工作队列demo"></a><font size=3>5. 并发管理工作队列demo</font></h2><h3 id="5-1-demo源码"><a href="#5-1-demo源码" class="headerlink" title="5.1 demo源码"></a><font size=3>5.1 demo源码</font></h3><p>demo源码可以看这里：<a target="_blank" rel="noopener" href="https://gitee.com/sumumm/imx6ull-driver-demo/tree/master/13_interrupt/11_nodts_workqueue_custom_cmwq">13_interrupt&#x2F;11_nodts_workqueue_custom_cmwq · 苏木&#x2F;imx6ull-driver-demo - 码云 - 开源中国</a></p>
<h3 id="5-2-开发板测试"><a href="#5-2-开发板测试" class="headerlink" title="5.2 开发板测试"></a><font size=3>5.2 开发板测试</font></h3><p>这个demo的现象并不是很明显，这里先大概了解一下：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323161027223.png" alt="image-20250323161027223" />

<h1 id="七、中断线程化"><a href="#七、中断线程化" class="headerlink" title="七、中断线程化  "></a><font size=3>七、中断线程化  </font></h1><p>中断线程化是实时 Linux 项目开发的一个新特性， 目的是降低中断处理对系统实时延迟的影响。  </p>
<h2 id="1-什么是中断线程化-？"><a href="#1-什么是中断线程化-？" class="headerlink" title="1. 什么是中断线程化 ？"></a><font size=3>1. 什么是中断线程化 ？</font></h2><p>中断线程化是一种优化技术， 用于提高多线程程序的性能。 想象一下， 我们正在做一项任务， 但是总是被别人的打扰所中断， 每次都要停下手头的工作去处理别人的事情。 这样频繁的中断会让我们的工作效率变低， 因为我们需要反复切换任务， 无法专心做好自己的工作。   </p>
<p>在多线程程序中， 也存在类似的问题。 有时硬件或其他事件会发出中断信号， 打断正在执行的线程， 需要切换到中断处理程序去处理这些事件。 这种频繁的中断切换会导致额外的开销和延迟， 影响程序的性能。  </p>
<p>为了解决这个问题， 中断线程化提出了一种优化方案。 它将中断处理程序从主线程中独立出来， 创建一个专门的线程来处理这些中断事件。 这样， 主线程就不再受到中断的干扰， 可以专注于自己的工作， 不再频繁地被打断。  </p>
<p>中断线程化的<strong>核心思想</strong>是将中断处理和主线程的工作分开， 让它们可以并行执行。 中断线程负责处理中断事件， 而主线程负责执行主要的工作任务。 这样一来， 不仅可以减少切换的开销， 还可以提高整个程序的响应速度和性能。  </p>
<p>需要注意的是， 中断线程化还需要处理线程之间的同步和数据共享问题。 因为中断线程和主线程可能会同时访问和修改共享的数据， 所以需要合理地进行同步操作， 确保数据的一致性和正确性。  </p>
<p>总而言之， 中断线程化是一种优化技术， 通过将中断处理和主线程的工作分开， 提高多线程程序的性能。 让主线程不再频繁被中断， 可以专注于自己的工作， 从而提高程序的效率和响应速度。  </p>
<p>中断线程化的处理仍然可以看作是将原来的中断上半部分和中断下半部分。 上半部分还是用来处理紧急的事情， 下半部分也是出路比较耗时的操作， 但是下半部分会交给一个专门的内核线程来处理。 这个内核线程只用于这个中断。 当发生中断的时候， 会唤醒这个内核线程， 然后由这个内核线程来执行中断下半部分的函数。  </p>
<h2 id="2-相关的api-1"><a href="#2-相关的api-1" class="headerlink" title="2. 相关的api"></a><font size=3>2. 相关的api</font></h2><h3 id="2-1-request-threaded-irq"><a href="#2-1-request-threaded-irq" class="headerlink" title="2.1 request_threaded_irq()"></a><font size=3>2.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1800">request_threaded_irq()</a></font></h3><p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1800">request_threaded_irq()</a> 是 Linux 内核中用于请求并注册一个线程化的中断处理函数的函数。  定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数参数</strong>：</p>
<ul>
<li>irq： 中断号， 表示要请求的中断线路。</li>
<li>handler： 是在发生中断时首先要执行的处理程序， 非常类似于上半部， 该函数最后会返回 IRQ_WAKE_THREAD 来唤醒中断， 一般 handler 设为 NULL， 用系统提供的默认处理。</li>
<li>thread_fn： 线程化的中断处理函数， 非常类似于下半部。 如果此处设置为 NULL 则表示没有使用中断线程化。</li>
<li>irqflags： 中断标志， 用于指定中断的属性和行为。</li>
<li>devname： 中断的名称， 用于标识中断请求的设备。</li>
<li>dev_id： 设备标识符， 用于传递给中断处理函数的参数。</li>
</ul>
<p><strong>返回值</strong>：返回一个整数值， 表示中断请求的结果。 如果中断请求成功， 返回值为 0， 否则返回一个负数错误代码。</p>
<blockquote>
<p>Tips：我们可以提供上半部函数，也可以不提供：</p>
<ul>
<li>如果不提供：内核会提供默认的上半部处理函数：irq_default_primary_handler，它是直接返回 IRQ_WAKE_THREAD。</li>
<li>如果提供的话：返回值必须是： IRQ_WAKE_THREAD。在 thread_fn 中，如果中断被正确处理了，应该返回 IRQ_HANDLED。</li>
</ul>
</blockquote>
<h3 id="2-2-free-irq"><a href="#2-2-free-irq" class="headerlink" title="2.2 free_irq()"></a><font size=3>2.2 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1759">free_irq()</a></font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *<span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(free_irq);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数用于释放中断。</p>
<h3 id="2-3-简单示例"><a href="#2-3-简单示例" class="headerlink" title="2.3 简单示例"></a><font size=3>2.3 简单示例</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数的底半部（线程化中断处理函数）</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_work</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 执行底半部的中断处理任务</span></span><br><span class="line">  msleep(<span class="number">1000</span>);</span><br><span class="line">  printk(<span class="string">&quot;This is test_work\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中断处理函数的顶半部</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;This is test_interrupt\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 将中断处理工作推迟到底半部</span></span><br><span class="line">  <span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">interrupt_irq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  irq = gpio_to_irq(<span class="number">18</span>); <span class="comment">// 将GPIO映射为中断号,imx6ull的GPIO1_IO18</span></span><br><span class="line">  printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">  <span class="comment">// 用于请求并注册一个线程化的中断处理函数</span></span><br><span class="line">  ret = request_threaded_irq(irq, test_interrupt, test_work, IRQF_TRIGGER_RISING, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;request_irq is error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">interrupt_irq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  free_irq(irq, <span class="literal">NULL</span>); <span class="comment">// 释放中断</span></span><br><span class="line">  printk(<span class="string">&quot;bye bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_irq_init);</span><br><span class="line">module_exit(interrupt_irq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="3-request-threaded-irq-机制"><a href="#3-request-threaded-irq-机制" class="headerlink" title="3. request_threaded_irq()机制"></a><font size=3>3. <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1800">request_threaded_irq()</a>机制</font></h2><p>前面我们学习了这个函数：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322142749855.png" alt="image-20250322142749855"  />

<p>我们可以只提供 thread_fn，系统会为这个函数创建一个内核线程。发生中断时，系统会立刻调用 handler 函数，然后唤醒某个内核线程，内核线程再来执行thread_fn 函数。 那，这是怎么过程呢？</p>
<h3 id="3-1-数据结构关系"><a href="#3-1-数据结构关系" class="headerlink" title="3.1 数据结构关系"></a><font size=3>3.1 数据结构关系</font></h3><p>调用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1800">request_threaded_irq()</a> 后内核的数据结构关系如下：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322142840493.png" alt="image-20250322142840493"  />



<h3 id="3-2-request-threaded-irq-函数"><a href="#3-2-request-threaded-irq-函数" class="headerlink" title="3.2 request_threaded_irq()函数"></a><font size=3>3.2 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1800">request_threaded_irq()</a>函数</font></h3><p>我们来看一下这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">	<span class="comment">// 分配、设置一个 irqaction 结构体</span></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;</span><br><span class="line">	action-&gt;thread_fn = thread_fn;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 进一步处理</span></span><br><span class="line">	retval = __setup_irq(irq, desc, action);</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(request_threaded_irq);</span><br></pre></td></tr></table></figure>

<p>这个函数中会先分配，设置一个 irqaction 结构体，后面会调用 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1216">__setup_irq()</a> 函数做一些进一步处理。</p>
<h4 id="3-2-1-setup-irq"><a href="#3-2-1-setup-irq" class="headerlink" title="3.2.1 __setup_irq()"></a><font size=3>3.2.1 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1216">__setup_irq()</a></font></h4><p>我们来看一下<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1216">__setup_irq()</a>，这个函数超级长，上百行，我们主要看关键的部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__setup_irq(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_desc *desc, <span class="keyword">struct</span> irqaction *new)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Create a handler thread when a thread function is supplied</span></span><br><span class="line"><span class="comment">	 * and the interrupt does not nest into another interrupt</span></span><br><span class="line"><span class="comment">	 * thread.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (new-&gt;thread_fn &amp;&amp; !nested) &#123;</span><br><span class="line">		ret = setup_irq_thread(new, irq, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out_mput;</span><br><span class="line">		<span class="keyword">if</span> (new-&gt;secondary) &#123;</span><br><span class="line">			ret = setup_irq_thread(new-&gt;secondary, irq, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">goto</span> out_thread;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面我们主要关注 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1160">setup_irq_thread()</a> 函数。</p>
<h4 id="3-2-2-setup-irq-thread"><a href="#3-2-2-setup-irq-thread" class="headerlink" title="3.2.2 setup_irq_thread()"></a><font size=3>3.2.2 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1160">setup_irq_thread()</a></font></h4><p>来看一下 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1160">setup_irq_thread()</a> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">setup_irq_thread</span><span class="params">(<span class="keyword">struct</span> irqaction *new, <span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">bool</span> secondary)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123;</span><br><span class="line">		.sched_priority = MAX_USER_RT_PRIO/<span class="number">2</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!secondary) &#123;</span><br><span class="line">		t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-%s&quot;</span>, irq,</span><br><span class="line">				   new-&gt;name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-s-%s&quot;</span>, irq,</span><br><span class="line">				   new-&gt;name);</span><br><span class="line">		param.sched_priority -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(t))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(t);</span><br><span class="line"></span><br><span class="line">	sched_setscheduler_nocheck(t, SCHED_FIFO, &amp;param);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We keep the reference to the task struct even if</span></span><br><span class="line"><span class="comment">	 * the thread dies to avoid that the interrupt code</span></span><br><span class="line"><span class="comment">	 * references an already freed task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	get_task_struct(t);</span><br><span class="line">	new-&gt;thread = t;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tell the thread to set its affinity. This is</span></span><br><span class="line"><span class="comment">	 * important for shared interrupt handlers as we do</span></span><br><span class="line"><span class="comment">	 * not invoke setup_affinity() for the secondary</span></span><br><span class="line"><span class="comment">	 * handlers as everything is already set up. Even for</span></span><br><span class="line"><span class="comment">	 * interrupts marked with IRQF_NO_BALANCE this is</span></span><br><span class="line"><span class="comment">	 * correct as we want the thread to move to the cpu(s)</span></span><br><span class="line"><span class="comment">	 * on which the requesting code placed the interrupt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_bit(IRQTF_AFFINITY, &amp;new-&gt;thread_flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是在这里创建了对应的线程。</p>
<h3 id="3-3-中断的执行过程"><a href="#3-3-中断的执行过程" class="headerlink" title="3.3 中断的执行过程"></a><font size=3>3.3 中断的执行过程</font></h3><p>对于 GPIO 中断，这部分我没有去试，直接参考的伟东山的linux教程，教程中使用 QEMU 的调试功能找出了所涉及的函数调用，其他板子可能稍有不同。调用关系如下，反过来看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, gpio_keys_gpio_isr (irq=200, dev_id=0x863e6930) at drivers/input/keybo</span><br><span class="line">ard/gpio_keys.c:393</span><br><span class="line">393 &#123;</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0 gpio_keys_gpio_isr (irq=200, dev_id=0x863e6930) at drivers/input/keyboard/gpio_keys.c:393</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1 0x80270528 <span class="keyword">in</span> __handle_irq_event_percpu (desc=0x8616e300, flags=0x86517edc) at kernel/irq/handle.c:145</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2 0x802705cc <span class="keyword">in</span> handle_irq_event_percpu (desc=0x8616e300) at kernel/irq/handle.c:185</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3 0x80270640 <span class="keyword">in</span> handle_irq_event (desc=0x8616e300) at kernel/irq/handle.c:202</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4 0x802738e8 <span class="keyword">in</span> handle_level_irq (desc=0x8616e300) at kernel/irq/chip.c:518</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5 0x8026f7f8 <span class="keyword">in</span> generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/irqdesc.h:150</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6 generic_handle_irq (irq=&lt;optimized out&gt;) at kernel/irq/irqdesc.c:590</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7 0x805005e0 <span class="keyword">in</span> mxc_gpio_irq_handler (port=0xc8, irq_stat=2252237104) at drivers/gpio/gpio-mxc.c:274</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8 0x805006fc <span class="keyword">in</span> mx3_gpio_irq_handler (desc=&lt;optimized out&gt;) at drivers/gpio/gpio-mxc.c:291</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9 0x8026f7f8 <span class="keyword">in</span> generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/irqdesc.h:150</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10 generic_handle_irq (irq=&lt;optimized out&gt;) at kernel/irq/irqdesc.c:590</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">11 0x8026fd0c <span class="keyword">in</span> __handle_domain_irq (domain=0x86006000, hwirq=32, lookup=<span class="literal">true</span>, regs=0x86517fb0) at kernel/irq/irqdesc.c:627</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">12 0x80201484 <span class="keyword">in</span> handle_domain_irq (regs=&lt;optimized out&gt;, hwirq=&lt;optimized out&gt;, domain=&lt;optimized out&gt;) at ./include/linux/irqdesc.h:168</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">13 gic_handle_irq (regs=0xc8) at drivers/irqchip/irq-gic.c:364</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">14 0x8020b704 <span class="keyword">in</span> __irq_usr () at <span class="built_in">arch</span>/arm/kernel/entry-armv.S:464</span></span><br></pre></td></tr></table></figure>

<p>我们只需要分析<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/handle.c#L137">__handle_irq_event_percpu()</a>:</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322144032880.png" alt="image-20250322144032880" style="zoom:50%;" />

<p>线程的处理函数为  <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.19.71/source/kernel/irq/manage.c#L1035">irq_thread()</a>：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250322144627197.png" alt="image-20250322144627197" style="zoom: 67%;" />

<h2 id="4-中断线程化demo"><a href="#4-中断线程化demo" class="headerlink" title="4. 中断线程化demo"></a><font size=3>4. 中断线程化demo</font></h2><h3 id="4-1-demo源码-1"><a href="#4-1-demo源码-1" class="headerlink" title="4.1 demo源码"></a><font size=3>4.1 demo源码</font></h3><p>demo源码可以看这里：<a target="_blank" rel="noopener" href="https://gitee.com/sumumm/imx6ull-driver-demo/tree/master/13_interrupt/12_nodts_threaded_irq">13_interrupt&#x2F;12_nodts_threaded_irq · 苏木&#x2F;imx6ull-driver-demo - 码云 - 开源中国</a></p>
<h3 id="4-2-开发板测试-1"><a href="#4-2-开发板测试-1" class="headerlink" title="4.2 开发板测试"></a><font size=3>4.2 开发板测试</font></h3><p>这个其实就和前面工作队列那些现象一样了：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323163609657.png" alt="image-20250323163609657" />

<p>但是我们可以看到有一条名为 irq&#x2F;79-key-0 的线程被创建了：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323163709969.png" alt="image-20250323163709969" />

<p>加载驱动前后的线程情况：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323163844304.png" alt="image-20250323163844304" />

<p>线程的名字其实就是我们申请的中断的时候的名字组合出来的：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/02IMX6ULL%E5%B9%B3%E5%8F%B0/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/LV06-13-%E4%B8%AD%E6%96%AD-03-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-02-%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97/img/image-20250323164045263.png" alt="image-20250323164045263" />



<blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/myarrow/article/details/9287169">中断处理下半部机制-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiangwan2011/article/details/7254806">软中断（softirq）机制_软中断机制-CSDN博客</a></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">




    <div>
        
            <div style="text-align:center;color: #ccc;font-size:14px;">
            ----------本文结束
            <i class="fas fa-fan fa-spin" style="color: #FF1493; font-size: 1rem"></i>
            感谢您的阅读----------
            </div>
        
    </div>





  
  <div class="my_post_copyright"> 
    <p><span>文章标题:</span><a href="/post/72a70fb1.html">LV06-13-中断-03-中断下半部-02-工作队列</a></p>
    <p><span>文章作者:</span><a href="/" title="欢迎访问 《苏木》 的学习笔记">苏木</a></p>
    <p><span>发布时间:</span>2025年03月23日 - 18:40</p>
    <p><span>最后更新:</span>2025年06月14日 - 00:25</p>
    <p><span>原始链接:</span><a href="/post/72a70fb1.html" title="LV06-13-中断-03-中断下半部-02-工作队列">https://sumumm.github.io/post/72a70fb1.html</a></p>
    <p><span>许可协议:</span><i class="fab fa-creative-commons"></i> <a rel="license" href= "https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
  </div>
  


          <div class="post-tags">
              <a href="/tags/LV06-%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/" rel="tag"><i class="fa fa-tag"></i> LV06-驱动开发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/1551cbe5.html" rel="prev" title="LV06-13-中断-01-中断基础">
                  <i class="fa fa-angle-left"></i> LV06-13-中断-01-中断基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/765d0409.html" rel="next" title="LV06-13-中断-03-中断下半部-01-tasklet">
                  LV06-13-中断-03-中断下半部-01-tasklet <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">苏木</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.7m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">225:26</span>
  </span>
</div>




    <span id="sitetime"></span>
    <script defer language=javascript>
        function siteTime()
        {
            window.setTimeout("siteTime()", 1000);
            var seconds = 1000;
            var minutes = seconds * 60;
            var hours = minutes * 60;
            var days = hours * 24;
            var years = days * 365;
            var today = new Date();
            var todayYear = today.getFullYear();
            var todayMonth = today.getMonth()+1;
            var todayDate = today.getDate();
            var todayHour = today.getHours();
            var todayMinute = today.getMinutes();
            var todaySecond = today.getSeconds();
            /*==================================================
            Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
            year        - 作为date对象的年份，为4位年份值
            month       - 0-11之间的整数，做为date对象的月份
            day         - 1-31之间的整数，做为date对象的天数
            hours       - 0(午夜24点)-23之间的整数，做为date对象的小时数
            minutes     - 0-59之间的整数，做为date对象的分钟数
            seconds     - 0-59之间的整数，做为date对象的秒数
            microseconds - 0-999之间的整数，做为date对象的毫秒数
            ==================================================*/
            var t1 = Date.UTC(2017, 
                              5, 
                              19, 
                              0, 
                              0, 
                              0); //北京时间
            var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
            var diff = t2-t1;
            var diffYears = Math.floor(diff/years);
            var diffDays = Math.floor((diff/days)-diffYears*365);
            var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
            var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
            var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
            document.getElementById("sitetime").innerHTML="已在这里 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
        }
        siteTime();
    </script>



    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


 
        <div id="click-show-text"
            data-mobile = false
            data-text = 富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善
            data-fontsize = 15px
            data-random= false>
        </div>
       

      
        <script async src=https://cdn.jsdelivr.net/npm/hexo-next-mouse-effect@latest/click/showText.js></script>
      

      
    




    <script async src="/js/fancybox_param.js"></script>





<!-- APlayer本体 -->



</body>
</html>
