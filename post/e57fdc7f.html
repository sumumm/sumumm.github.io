<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.css" integrity="sha256-6cQIC71/iBIYXFK+0RHAvwmjwWzkWd+r7v/BX3/vZDc=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/green/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"sumumm.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":300},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="本文主要是C语言基础——多文件编程相关笔记，若笔记中有错误或者不合适的地方，欢迎批评指正😃。">
<meta property="og:type" content="article">
<meta property="og:title" content="LV01-08-C语言-多文件">
<meta property="og:url" content="https://sumumm.github.io/post/e57fdc7f.html">
<meta property="og:site_name" content="苏木">
<meta property="og:description" content="本文主要是C语言基础——多文件编程相关笔记，若笔记中有错误或者不合适的地方，欢迎批评指正😃。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419080208035.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419105929631.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419111437250.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419121748007.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20250323194559442.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419220121990.png">
<meta property="og:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419221732388.png">
<meta property="article:published_time" content="2022-01-17T23:20:08.000Z">
<meta property="article:modified_time" content="2025-06-13T16:25:56.985Z">
<meta property="article:author" content="苏木">
<meta property="article:tag" content="LV01-C语言基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419080208035.png">


<link rel="canonical" href="https://sumumm.github.io/post/e57fdc7f.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sumumm.github.io/post/e57fdc7f.html","path":"post/e57fdc7f.html","title":"LV01-08-C语言-多文件"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LV01-08-C语言-多文件 | 苏木</title>
  








    <script src="/js/browser_tools_disable.js"></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.com/hexo-next-tags-plus@latest/lib/tag_plus.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">苏木</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我的学习之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>苏木的家</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类页<span class="badge">42</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档页<span class="badge">673</span></a></li><li class="menu-item menu-item-flink"><a href="/flink/" rel="section"><i class="fa fa-link fa-fw"></i>友人帐</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="nav-text">一、多文件编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">1. 一个简单的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-extern-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">2. extern 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-text">2.1 函数声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="nav-text">2.2 变量声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-GCC-%E7%BC%96%E8%AF%91%E5%9F%BA%E7%A1%80"><span class="nav-text">二、 GCC 编译基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-text">1. 预处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-text">1.1 预处理的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-text">1.2 预处理的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E9%A2%84%E5%A4%84%E7%90%86%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-text">1.3 预处理的命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BC%96%E8%AF%91"><span class="nav-text">2. 编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%BC%96%E8%AF%91%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-text">2.1 编译的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E7%BC%96%E8%AF%91%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-text">2.2 编译的命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B1%87%E7%BC%96"><span class="nav-text">3. 汇编</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%B1%87%E7%BC%96%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-text">3.1 汇编的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%B1%87%E7%BC%96%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-text">3.2 汇编的命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%93%BE%E6%8E%A5"><span class="nav-text">4. 链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E9%93%BE%E6%8E%A5%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-text">4.1 链接的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E9%93%BE%E6%8E%A5%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-text">4.2 链接的命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-text">三、目标文件和可执行文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-text">1. 文件格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-text">2. 目标文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-text">3. 可执行文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%AE%B5%E5%90%88%E5%B9%B6"><span class="nav-text">4. 段合并</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%AC%A6%E5%8F%B7"><span class="nav-text">四、符号 </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 符号的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91"><span class="nav-text">2. 模块化开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%AC%A6%E5%8F%B7%E5%86%B3%E8%AE%AE"><span class="nav-text">3. 符号决议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%BC%BA%E5%BC%B1%E7%AC%A6%E5%8F%B7"><span class="nav-text">4. 强弱符号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%BC%BA%E5%BC%B1%E7%AC%A6%E5%8F%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">4.1 强弱符号是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-text">4.2 怎么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-text">4.3 有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E4%B8%80%E4%B8%AA%E5%9D%91"><span class="nav-text">4.4 一个坑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%BC%BA%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-text">5. 强弱引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">五、头文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-C-%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">1. C 语言标准库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">2. 自定义头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A4%B4%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="nav-text">3. 头文件路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%87%8D%E5%A4%8D%E5%BC%95%E5%85%A5"><span class="nav-text">4. 重复引入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">4.1 有什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">4.2 如何解决？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81-extern-%E4%B8%8E-h"><span class="nav-text">六、 extern 与 .h </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">1. 头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-extern"><span class="nav-text">2. extern </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%B8%A4%E8%80%85%E8%81%94%E7%B3%BB"><span class="nav-text">3. 两者联系</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="苏木"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">苏木</p>
  <div class="site-description" itemprop="description">莫道桑榆晚，为霞尚满天</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">673</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sumumm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sumumm" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sumumm.github.io/post/e57fdc7f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="苏木">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="苏木">
      <meta itemprop="description" content="莫道桑榆晚，为霞尚满天">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LV01-08-C语言-多文件 | 苏木">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LV01-08-C语言-多文件
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-18 07:20:08" itemprop="dateCreated datePublished" datetime="2022-01-18T07:20:08+08:00">2022-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">嵌入式开发</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/" itemprop="url" rel="index"><span itemprop="name">01HQ课程体系</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">LV01-C语言基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>48 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文主要是C语言基础——多文件编程相关笔记，若笔记中有错误或者不合适的地方，欢迎批评指正😃。</p>
<span id="more"></span>

<!-- Photo: https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/ -->

<details class="folding-tag" blue><summary> 点击查看使用工具及版本 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center" width=150px>Windows</td>        <td align="left">windows11</td>    </tr>    <tr>        <td align="center">Ubuntu</td>        <td align="left">Ubuntu16.04的64位版本</td>      </tr>    <tr>        <td align="center">VMware® Workstation 16 Pro</td>        <td align="left">16.2.3 build-19376536</td>      </tr>    <tr>        <td align="center">SecureCRT</td>        <td align="left">Version 8.7.2 (x64 build 2214)   -   正式版-2020年5月14日</td>      </tr>    <tr>        <td align="center">开发板</td>        <td align="left">正点原子 i.MX6ULL Linux阿尔法开发板</td>      </tr>    <tr>        <td align="center">uboot</td>        <td align="left">NXP官方提供的uboot，NXP提供的版本为uboot-imx-rel_imx_4.1.15_2.1.0_ga(使用的uboot版本为U-Boot 2016.03)</td>      </tr>    <tr>        <td align="center">linux内核</td>        <td align="left">linux-4.15(NXP官方提供)</td>      </tr>    <tr>        <td align="center">STM32开发板</td>        <td align="left">正点原子战舰V3(STM32F103ZET6)</td>      </tr></table>
              </div>
            </details>

<details class="folding-tag" blue><summary> 点击查看本文参考资料 </summary>
              <div class='content'>
              <table>    <tr><td align="center">参考方向  </td><td align="center">参考原文</td></tr>    <tr><td align="left">---</td><td align="left"><a href="" target="_blank">--- <i class="fa fa-external-link-alt"></i> </a></td></tr></table>
              </div>
            </details>

<details class="folding-tag" blue><summary> 点击查看相关文件下载 </summary>
              <div class='content'>
              <table>    <tr>        <td align="center">---</td>        <td align="left">--- <a href="" target="_blank">  <i class="fa fa-external-link-alt"></i></a></td>      </tr></table>
              </div>
            </details>

<h1 id="一、多文件编程"><a href="#一、多文件编程" class="headerlink" title="一、多文件编程"></a><font size=3>一、多文件编程</font></h1><p>前边学习函数的时候，我们把函数全部都放在一个文件中，函数少的话倒是无所谓，很多的话，就不是很方便了。 C 语言是支持多文件编程的，我们可以将某些功能放入独立的源文件，形成一个单独的模块，这样不仅便于阅读，也更加方便维护。这也可以称之为模块化编程。</p>
<h2 id="1-一个简单的例子"><a href="#1-一个简单的例子" class="headerlink" title="1. 一个简单的例子"></a><font size=3>1. 一个简单的例子</font></h2><p>首先来看一个例子，了解一下多文件编程时程序的编译和运行吧。</p>
<details class="folding-tag" blue><summary> 点击查看实例 </summary>
              <div class='content'>
              <div class="tabs" id="tabname1"><ul class="nav-tabs"><li class="tab active"><a href="#tabname1-1">main.c</a></li><li class="tab"><a href="#tabname1-2">fun1.c</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall    # 编译程序 </span><br></pre></td></tr></table></figure><p>会在终端看到以下提示信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main.c: In function ‘main’:</span><br><span class="line">main.c:5:5: warning: implicit declaration of function ‘fun1’ [-Wimplicit-function-declaration]</span><br><span class="line">     fun1();</span><br><span class="line">     ^~~~</span><br></pre></td></tr></table></figure><p>虽然有警告，但是依然生成了 a.out 可执行文件，终端运行 .&#x2F;a.out 命令，看到有如下信息输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun1</span><br></pre></td></tr></table></figure><p>这说明，虽然有警告，但是依然正常调用了函数。</p>
              </div>
            </details>

<p>看过例子，会发现，这样写出来的程序是有警告的，原因应该就在于函数应该先声明，再调用，这个问题我们下边再解决。</p>
<h2 id="2-extern-关键字"><a href="#2-extern-关键字" class="headerlink" title="2. extern 关键字"></a><font size=3>2. extern 关键字</font></h2><p> C 语言代码是由上到下依次执行的，不管是变量还是函数，原则上都要先定义再使用，否则就会报错。但在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明。声明（ Declaration ），就是告诉编译器现在要使用这个变量或函数，现在没有找到它的定义不要紧，不要报错，后边会有定义的。</p>
<h3 id="2-1-函数声明"><a href="#2-1-函数声明" class="headerlink" title="2.1 函数声明"></a><font size=3>2.1 函数声明</font></h3><p>在前边学习函数的时候提到过函数声明，那时并没有使用  extern  关键字，因为函数的定义有函数体，函数的声明没有函数体，编译器很容易区分定义和声明，所以对于函数声明来说，有没有  extern  都是一样的。所以函数的声明可以有以下形式，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不使用 extern */</span></span><br><span class="line">dataType <span class="title function_">function</span><span class="params">( dataType arg1, dataType arg2, ... )</span>;</span><br><span class="line">dataType <span class="title function_">function</span><span class="params">( dataType1, dataType2, ... )</span>;</span><br><span class="line"><span class="comment">/* 使用 extern */</span></span><br><span class="line"><span class="keyword">extern</span> dataType <span class="title function_">function</span><span class="params">( dataType1 arg1, dataType2 arg2, ... )</span>;</span><br><span class="line"><span class="keyword">extern</span> dataType <span class="title function_">function</span><span class="params">( ddataType1, dataType2, ... )</span>;</span><br></pre></td></tr></table></figure>

<details class="folding-tag" blue><summary> 点击查看实例 </summary>
              <div class='content'>
              <div class="tabs" id="tabname2"><ul class="nav-tabs"><li class="tab active"><a href="#tabname2-1">main.c</a></li><li class="tab"><a href="#tabname2-2">fun1.c</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname2-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname2-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall    # 编译程序 </span><br></pre></td></tr></table></figure><p>会发现没有警告了，然后在终端运行 .&#x2F;a.out 命令，看到有如下信息输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun1</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h3 id="2-2-变量声明"><a href="#2-2-变量声明" class="headerlink" title="2.2 变量声明"></a><font size=3>2.2 变量声明</font></h3><p>变量和函数不同，编译器只能根据  extern  来区分，有  extern  才是声明，没有  extern  就是定义。变量的声明只有一种形式，就是使用  extern  关键字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> dataType name;</span><br></pre></td></tr></table></figure>

<details class="folding-tag" blue><summary> 点击查看实例 </summary>
              <div class='content'>
              <div class="tabs" id="tabname3"><ul class="nav-tabs"><li class="tab active"><a href="#tabname3-1">main.c</a></li><li class="tab"><a href="#tabname3-2">fun1.c</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname3-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname3-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1 a=%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall    # 编译程序 </span><br><span class="line">./a.out          # 运行可执行程序</span><br></pre></td></tr></table></figure><p>会看到有如下信息输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun1 a=10</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<p>【注意】变量不要在声明的同时初始化，格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> dataType name = value;</span><br></pre></td></tr></table></figure>

<p>但是这种方式会有警告，并且不会正常生成可执行文件。</p>
<details class="folding-tag" blue><summary> 点击查看警告信息 </summary>
              <div class='content'>
              <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.c:4:12: warning: ‘a’ initialized and declared ‘extern’</span><br><span class="line"> extern int a = 10;</span><br><span class="line">            ^</span><br><span class="line">/tmp/ccy6uPA9.o:(.data+0x0):  a&#x27;被多次定义</span><br><span class="line">/tmp/ccfIMEHM.o:(.data+0x0)：第一次在此定义</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
              </div>
            </details>



<h1 id="二、-GCC-编译基础"><a href="#二、-GCC-编译基础" class="headerlink" title="二、 GCC 编译基础"></a><font size=3>二、 GCC 编译基础</font></h1><p>前边我们使用的 GCC 编译器来生成可执行文件，那么生成可执行文件的中间经历了什么呢？这些其实没必要关心，但是如果了解的话可以帮助我们更好的理解多文件编程。</p>
<p>查阅资料会知道，从源代码生成可执行文件可以分为四个步骤，分别是预处理（ Preprocessing ）、编译（ Compilation ）、汇编（ Assembly ）和链接（ Linking ）。</p>
<details class="folding-tag" blue><summary> 点击查看测试文件内容 </summary>
              <div class='content'>
              <ul><li>简单的只使用一个文件用于测试，文件名称为 test.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;N = %d \n&quot;</span>, N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<h2 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1. 预处理"></a><font size=3>1. 预处理</font></h2><p>预处理，主要是处理源文件和头文件中以 # 开头的命令，包括 #include 、 #define 、 #ifdef  等（关于这些后边还会详细学习）。</p>
<h3 id="1-1-预处理的规则"><a href="#1-1-预处理的规则" class="headerlink" title="1.1 预处理的规则"></a><font size=3>1.1 预处理的规则</font></h3><ul>
<li>删除所有 #define ，并展开所有的宏定义。</li>
<li>处理所有条件编译命令，包括 #if 、 #ifdef 、 #elif 、 #else 、 #endif  等。</li>
<li>处理 #include 命令，将被包含文件的内容插入到该命令所在的位置。注意，这个过程是递归进行的，也就是说被包含的文件可能还会包含其他的文件。</li>
<li>删除所有的注释，包括 &#x2F;&#x2F; 和 &#x2F;* … *&#x2F; 。</li>
<li>添加行号和文件名标识，便于在调试和出错时给出具体的代码位置。</li>
<li>由于编译器的需要，预处理阶段会保留所有的 #pragma 命令。</li>
</ul>
<h3 id="1-2-预处理的结果"><a href="#1-2-预处理的结果" class="headerlink" title="1.2 预处理的结果"></a><font size=3>1.2 预处理的结果</font></h3><p>预处理的结果是生成 .i 文件， .i 文件是包含 C 语言代码的源文件，只不过在此文件中所有的宏已经被展开，所有包含的文件已经被插入到当前文件中。</p>
<h3 id="1-3-预处理的命令"><a href="#1-3-预处理的命令" class="headerlink" title="1.3 预处理的命令"></a><font size=3>1.3 预处理的命令</font></h3><p>在 linux 下，我们使用 GCC 编译来生成预处理文件的命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i</span><br></pre></td></tr></table></figure>

<p>我们打开这个 test.i 文件就可以看到其中的内容，这里只截取一部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">31</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">32</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">中间部分省略...</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;N = %d \n&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a><font size=3>2. 编译</font></h2><p>编译就是把预处理完的文件进行一些列的词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件。编译是整个程序构建的核心部分，也是最复杂的部分之一。</p>
<p>由于比较复杂，而且对我来说不是关注重点，这里就简单介绍，不再详写了。毕竟就这一部分的东西就有一本叫《编译原理》的书来详细解释了😂。</p>
<h3 id="2-1-编译的结果"><a href="#2-1-编译的结果" class="headerlink" title="2.1 编译的结果"></a><font size=3>2.1 编译的结果</font></h3><p>编译的结果就是生成汇编文件， GCC 中它以 .s 为后缀名，其他编译器下可能以 .asm 为后缀。</p>
<h3 id="2-2-编译的命令"><a href="#2-2-编译的命令" class="headerlink" title="2.2 编译的命令"></a><font size=3>2.2 编译的命令</font></h3><p>在 linux 下，我们使用 GCC 编译来生成汇编文件的命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s</span><br><span class="line"><span class="comment">/* 或者也可以由源文件直接得到 */</span></span><br><span class="line">gcc -S test.c -o test.s</span><br></pre></td></tr></table></figure>

<p>我们打开这个 test.s 文件就可以看到其中的内容，将 C 语言源代码转化为了汇编语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">	.file	<span class="string">&quot;test.c&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.<span class="built_in">string</span>	<span class="string">&quot;N = %d \n&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">	.cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">	subq	$<span class="number">16</span>, %rsp</span><br><span class="line">	movl	%edi, <span class="number">-4</span>(%rbp)</span><br><span class="line">	movq	%rsi, <span class="number">-16</span>(%rbp)</span><br><span class="line">	movl	$<span class="number">100</span>, %esi</span><br><span class="line">	leaq	.LC0(%rip), %rdi</span><br><span class="line">	movl	$<span class="number">0</span>, %eax</span><br><span class="line">	call	<span class="built_in">printf</span>@PLT</span><br><span class="line">	movl	$<span class="number">0</span>, %eax</span><br><span class="line">	leave</span><br><span class="line">	.cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	<span class="string">&quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span></span><br><span class="line">	.section	.note.GNU-<span class="built_in">stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3. 汇编"></a><font size=3>3. 汇编</font></h2><p>汇编的过程就是将汇编代码转换成可以执行的机器指令。</p>
<h3 id="3-1-汇编的结果"><a href="#3-1-汇编的结果" class="headerlink" title="3.1 汇编的结果"></a><font size=3>3.1 汇编的结果</font></h3><p>汇编的结果是产生目标文件，这个文件是二进制文件。它在  GCC  下的后缀为 .o ，在 其他编译器下的后缀可能为 .obj 。</p>
<h3 id="3-2-汇编的命令"><a href="#3-2-汇编的命令" class="headerlink" title="3.2 汇编的命令"></a><font size=3>3.2 汇编的命令</font></h3><p>在 linux 下，我们使用 GCC 编译来生成目标文件的命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o</span><br><span class="line"><span class="comment">/* 或者也可以由源文件直接得到 */</span></span><br><span class="line">gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure>

<p>一般来说，这个二进制文件我们是打不开的，不过也没有必要里边的详细内容。</p>
<h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4. 链接"></a><font size=3>4. 链接</font></h2><p>目标文件已经是二进制文件，与可执行文件的组织形式类似，但是有些函数和全局变量的地址还未找到，程序不能执行。</p>
<p>链接的作用就是找到那些目标地址，将<strong>所有的目标文件组织成一个可以执行的二进制文件</strong>。</p>
<h3 id="4-1-链接的结果"><a href="#4-1-链接的结果" class="headerlink" title="4.1 链接的结果"></a><font size=3>4.1 链接的结果</font></h3><p>链接的结果是产生可执行文件，这个文件是二进制文件。它在  GCC  下默认的名称为 a.out ，在其他编译器下的后缀可能为 .exe 。</p>
<h3 id="4-2-链接的命令"><a href="#4-2-链接的命令" class="headerlink" title="4.2 链接的命令"></a><font size=3>4.2 链接的命令</font></h3><p>在 linux 下，我们使用 GCC 编译来生成可执行文件的命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o         <span class="comment">/* 生成文件名称默认 */</span></span><br><span class="line">gcc test.o -o test <span class="comment">/* 生成文件名称指定为test */</span></span><br><span class="line"><span class="comment">/* 或者也可以由源文件直接得到 */</span></span><br><span class="line">gcc test.c         <span class="comment">/* 生成文件名称默认 */</span></span><br><span class="line">gcc test.c -o test <span class="comment">/* 生成文件名称指定为test */</span></span><br></pre></td></tr></table></figure>

<h1 id="三、目标文件和可执行文件"><a href="#三、目标文件和可执行文件" class="headerlink" title="三、目标文件和可执行文件"></a><font size=3>三、目标文件和可执行文件</font></h1><p>上边我们看到最后生成的有目标文件和可执行文件，它们都是二进制文件，那么它们的组织形式是怎样的呢？</p>
<h2 id="1-文件格式"><a href="#1-文件格式" class="headerlink" title="1. 文件格式"></a><font size=3>1. 文件格式</font></h2><p>现在PC平台上流行的可执行文件格式主要有两种，一种是  Windows  下的  PE ( Portable Executable )和，另一种是 Linux  下的  ELF ( Executable Linkable Format )，它们都是  COFF ( Common File Format )格式的变种。</p>
<p> COFF  是  Unix V3 首先提出的规范，微软在此基础上制定了 PE 格式标准，并将它用于 Windows。后来 Unix V4 又在 COFF 的基础上引入了 ELF 格式，被  Linux  广泛使用。所以  Windows  和  Linux  上的可执行文件非常相似。</p>
<p>其中目标文件与可执行文件的存储格式几乎是一样的，我们可以将它们看成是同一种类型的文件，在  Windows  下，它们统称为  PE  文件，在  Linux  下，将它们统称为  ELF 文件。</p>
<h2 id="2-目标文件"><a href="#2-目标文件" class="headerlink" title="2. 目标文件"></a><font size=3>2. 目标文件</font></h2><p>整体上看，编译生成的目标文件被划分成了多个部分，每个部分叫做一个<strong>段</strong>（ Section ）。在 Linux 中  GCC  生成的目标文件的格式如下：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419080208035.png" alt="image-20220419080208035" style="zoom:50%;" />

<p>【说明】</p>
<p>（1）段名大都以 . 作为前缀，表示这些名字是系统保留的。</p>
<p>（2）除了上边系统保留的段名，应用程序也可以使用其它名字定义自己的段，应用程序自定义的的段不建议使用 . 作为前缀，否则容易和系统保留段发生冲突。例如，在在  ELF  文件中插入一个名为 music 的段来保存  MP3  音频数据。</p>
<p>（3）图中仅列出一些关键的段名称，还有一些隐藏在 Other Data 也就是其他数据中。</p>
<details class="folding-tag" blue><summary> 点击查看各部分说明 </summary>
              <div class='content'>
              <table>    <tr><td align="center" width=100px>段名</td><td align="center"> 说明</td></tr>    <tr><td align="center" width=100px>ELF Header</td><td align="left">文件头，描述了整个目标文件的属性，包括是否可执行、是动态链接还是静态链接、入口地址、目标硬件、目标操作系统、段表偏移等信息。</td></tr>    <tr><td align="center" width=100px>.text</td><td align="left">代码段，存放编译后的机器指令，也即各个函数的二进制代码。</td></tr>    <tr><td align="center" width=100px>.data</td><td align="left">数据段，存放全局变量和静态变量。</td></tr>    <tr><td align="center" width=100px>.rodata</td><td align="left">只读数据段，存放一般的常量、字符串常量等。</td></tr>    <tr><td align="center" width=100px>.rel.text<br>.rel.data</td><td align="left">重定位段，包含了目标文件中需要重定位的全局符号以及重定位入口。</td></tr>    <tr><td align="center" width=100px>.comment</td><td align="left">注释信息段，存放的是编译器的版本信息，比如 GCC:(GUN) 4.2.0 。</td></tr>    <tr><td align="center" width=100px>.debug</td><td align="left">调试信息。</td></tr>    <tr><td align="center" width=100px>.line</td><td align="left">调试时的行号表，就是源代码行号与编译后指令的对应表。</td></tr>    <tr><td align="center" width=100px>Section Table</td><td align="left">段表，描述了 ELF 文件包含的所有段的信息，比如段的名字、段的长度、在文件中的偏移、读写权限以及其他属性。可以说，ELF 文件的段结构是由段表来决定的，编译器、链接器和装载器都是依靠段表来定位和访问各个段的。</td></tr>    <tr><td align="center" width=100px>.strtab</td><td align="left">字符串表，保存了 ELF 文件用到的字符串，比如变量名、函数名、段名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难，常见的做法就是把字符串集中起来存放到一个表中，然后使用字符串在表中的偏移来引用字符串。</td></tr>    <tr><td align="center" width=100px>.symtab</td><td align="left">符号表，保存了全局变量名、局部变量名、函数名等在字符串表中的偏移。</td></tr></table>
              </div>
            </details>

<h2 id="3-可执行文件"><a href="#3-可执行文件" class="headerlink" title="3. 可执行文件"></a><font size=3>3. 可执行文件</font></h2><p>可执行文件与目标文件的组织形式非常类似，在 Linux 中  GCC  生成的目标文件的格式如下：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419105929631.png" alt="image-20220419105929631" style="zoom:33%;" />

<p>【说明】</p>
<p>（1）图中仅列出一些关键的段名称，还有一些隐藏在 Other Data 也就是其他数据中。</p>
<p>（2）红色字体为相对于目标文件，可执行文件新增的一些段，画有删除线的是可执行文件删除的一些段。</p>
<p>（3）右侧为 32 位环境的 Linux 内存模型。</p>
<p>（4）可执行文件在加载时实际上是被映射的虚拟地址空间，所以可执行文件很多时候又被叫做<strong>映像文件</strong>（ Image ）。</p>
<h2 id="4-段合并"><a href="#4-段合并" class="headerlink" title="4. 段合并"></a><font size=3>4. 段合并</font></h2><p>编译器生成的是目标文件，而我们最终需要的是可执行文件，链接（ Linking ）的作用就是将多个目标文件合并成一个可执行文件。在链接过程中，链接器会将多个目标文件中的代码段、数据段、调试信息等合并成可执行文件中的一个段，链接器还会删除多余的段（例如重定位段、段表等），增加其他段（例如程序头表等）。</p>
<p>段的合并仅仅是一个简单的叠加过程，如下图所示。</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419111437250.png" alt="image-20220419111437250" style="zoom:50%;" />

<h1 id="四、符号"><a href="#四、符号" class="headerlink" title="四、符号 "></a><font size=3>四、符号 </font></h1><p>其实多数情况下，我们的程序都不会只有一个源文件，大多有很多的源文件，他们都会生成目标文件（ Linux 中 GCC 编译后为 .o 文件），但是最终只有一个可执行文件，这个可执行文件与那些目标文件是怎样联系起来的呢？为什么我们可以把不同的模块写在不同的源文件进行模块化开发呢？大多数情况下完全不用考虑这两个问题，它并不会影响我们写程序，但是我觉得吧了解一下总归是好的，这样我们也可以更好的理解链接到底做了什么。</p>
<h2 id="1-符号的概念"><a href="#1-符号的概念" class="headerlink" title="1. 符号的概念"></a><font size=3>1. 符号的概念</font></h2><p>数据是保存在内存中的，对于计算机硬件来说，必须知道它的地址才能使用。变量名、函数名等仅仅是地址的一种助记符，目的是在编程时更加方便地使用数据，当源文件被编译成可执行文件后，这些标识符都不存在了，它们被替换成了数据的地址。</p>
<details class="folding-tag" blue><summary> 点击查看实例 </summary>
              <div class='content'>
              <p>假设变量  a 、 b 、 c  的地址分别为  0x0000 、 0x0004 、 0x0008 ，加法运算的机器指令为  1000 ，赋值运算的机器指令为  1001 ，那么在 C 语言中实现加法运算，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a + b;</span><br></pre></td></tr></table></figure><p>当生成可执行文件后的机器码就如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span>  <span class="number">0X0000</span>  <span class="number">0X0004</span>  <span class="comment">/* 将两个数据相加的值保存在一个临时区域 */</span></span><br><span class="line"><span class="number">1001</span>  <span class="number">0X0008</span>          <span class="comment">/* 将临时区域中的数据复制到地址为0X1008的内存中 */</span></span><br></pre></td></tr></table></figure>
              </div>
            </details>

<p>计算机刚刚诞生的时候没有编程语言，人们直接使用机器语言（二进制）编程。现在假设有一种跳转指令，它的二进制形式为  0001 ，如果需要执行地址为  1010  的代码，那么就可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0001</span> <span class="number">1010</span></span><br></pre></td></tr></table></figure>

<p>但是程序序并不是一写好就不再变化，它可能会经常被修改。例如我们在地址  1010  之前插入了其他指令，那么原来的代码就得往后移动，这样的话上面的跳转指令的跳转地址也得相应地调整。</p>
<p>在这个过程中，程我们需要人工重新计算每个子程序或者跳转的目标地址，这种重新计算各个目标地址的过程叫做<strong>重定位</strong>（ Relocation ）。每次程序修改时，这些位置都要重新计算，十分繁琐又耗时，并且很容易出错。如果程序包含了多个源文件，就很可能会有跨文件的跳转，这种人工重定位的方式在程序拥有多个模块时会导致更加严重的问题。</p>
<p>为了解决这些问题，汇编语言( Assembly )诞生了，汇编语言使用接近人类的各种符号和标记来帮助记忆，比如用 jmp 表示跳转指令，用 func 表示一个子程序（ C 语言中的函数就是一个子程序）的起始地址，这种符号的方法使得人们从具体的机器指令和二进制地址中解放出来。上边的机器码写成汇编的形式就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp func</span><br></pre></td></tr></table></figure>

<p>这样，不管在  func  之前增加或者减少了多少条指令导致  func  的地址发生了变化，汇编器在每次汇编程序的时候会重新计算  func  这个符号的地址，然后把所有使用到  func  的地方修正为新的地址。</p>
<p>于是，<strong>符号</strong>（ Symbol ）这个概念随着汇编语言的普及被人们广泛接受，它用来<strong>表示一个地址</strong>，这个地址可能是一段子程序（后来发展为函数）的起始地址，也可以是一个变量的地址。</p>
<h2 id="2-模块化开发"><a href="#2-模块化开发" class="headerlink" title="2. 模块化开发"></a><font size=3>2. 模块化开发</font></h2><p>我们自己写程序的时候也会将不同功能的代码放入单独的文件，形成模块，这些模块之间相互依赖又相互独立，原则上每个模块都可以单独开发、编译、测试，改变一个模块中的代码不需要编译整个程序。哈哈，不懂就问，这些模块是怎么被联系起来的呢？其实以前只管写，属实不知道其中原因。</p>
<p>在 C 语言中，模块（可以理解为源文件，就是我们写的 .c 文件）之间的依赖关系主要有两种：一种是<strong>模块间的函数调用</strong>，另外一种是<strong>模块间的变量访问</strong>。<strong>函数调用需要知道函数的首地址</strong>，<strong>变量访问需要知道变量的地址</strong>，所以这两种方式可以归结为一种，那就是模块间的<strong>符号引用</strong>。模块间依靠符号来交流，这其实很类似于拼图版，定义符号的模块多出一个区域，引用符号的模块刚好少了那一块区域，两者刚好完美组合。如下图所示：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419121748007.png" alt="image-20220419121748007" style="zoom: 33%;" />

<p><strong>通过符号将多个模块拼接为一个独立的程序</strong>的过程就叫做<strong>链接</strong>（ Linking ）。我们可以将符号看做是链接中的粘合剂，整个链接过程正是基于符号才能正确完成。</p>
<p>所有的符号都保存在符号表 .symtab 中，它一个结构体数组，每个数组元素都包含了一个符号的信息，包括符号名、符号在段中的偏移、符号大小（符号所占用的字节数）、符号类型等。在符号表中的符号包括：</p>
<ul>
<li><p>全局符号，也就是函数和全局变量，它们可以被其他目标文件引用。</p>
</li>
<li><p>外部符号（ External Symbol ），也就是在当前文件中使用到、却没有在当前文件中定义的全局符号。</p>
</li>
<li><p>局部符号，也就是局部变量。它们只在函数内部可见，对链接过程没有作用，所以链接器往往也忽略它们。</p>
</li>
<li><p>段名，这种符号往往由编译器产生，它的值就是该段的起始地址，比如 .text 、 .data 等。</p>
</li>
</ul>
<blockquote>
<p>确切地说，真正的符号名字是保存在字符串表 .strtab 中的，符号表仅仅保存了当前符号在字符串表中的偏移。</p>
</blockquote>
<h2 id="3-符号决议"><a href="#3-符号决议" class="headerlink" title="3. 符号决议"></a><font size=3>3. 符号决议</font></h2><p>当要进行链接时，链接器首先扫描所有的目标文件，获得各个段的长度、属性、位置等信息，并将目标文件中的所有（符号表中的）符号收集起来，统一放到一个全局符号表。同时，链接器会将目标文件中的各个段合并到可执行文件，并计算出合并后的各个段的长度、位置、虚拟地址等。</p>
<p>在目标文件的符号表中，保存了各个符号在段内的偏移，生成可执行文件后，原来各个段（ Section ）起始位置的虚拟地址就确定了下来，这样，使用起始地址加上偏移量就能够得到符号的地址（在进程中的虚拟地址）。这种计算符号地址的过程被称为<strong>符号决议</strong>（ Symbol Resolution ）。</p>
<p>重定位表 .rel.text 和 .rel.data 中保存了需要重定位的全局符号以及重定位入口，完成了符号决议，链接器会根据重定位表调整代码中的地址，使它指向正确的内存位置。至此，可执行文件就生成了，链接器的任务也随之完成。</p>
<h2 id="4-强弱符号"><a href="#4-强弱符号" class="headerlink" title="4. 强弱符号"></a><font size=3>4. 强弱符号</font></h2><h3 id="4-1-强弱符号是什么？"><a href="#4-1-强弱符号是什么？" class="headerlink" title="4.1 强弱符号是什么？"></a><font size=3>4.1 强弱符号是什么？</font></h3><p>可以先看个例子：</p>
<div class="tabs" id="tabname4"><ul class="nav-tabs"><li class="tab active"><a href="#tabname4-1">main.c</a></li><li class="tab"><a href="#tabname4-2">fun1.c</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname4-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname4-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1 a=%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>在终端执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall    # 编译程序 </span><br></pre></td></tr></table></figure>

<p>会看到终端有如下信息输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccjAxzo8.o:(.data+0x0):  a&#x27;被多次定义</span><br><span class="line">/tmp/ccxtucvP.o:(.data+0x0)：第一次在此定义</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>这是一种符号重复定义（ Multiple Definition ）的错误，是因为在多个源文件中定义了名字相同的全局变量，并且都将它们初始化了，这种符号的定义可以被称为强符号。</p>
<p>在 C 语言中，编译器默认函数和初始化了的全局变量为<strong>强符号</strong>（ Strong Symbol ），未初始化的全局变量为弱符号（ Weak Symbol ）。强符号强在它拥有确切的数据，变量有值，函数有函数体；弱符号弱在它还未被初始化，没有确切的数据。</p>
<h3 id="4-2-怎么处理？"><a href="#4-2-怎么处理？" class="headerlink" title="4.2 怎么处理？"></a><font size=3>4.2 怎么处理？</font></h3><p>链接器会按照如下的<strong>规则</strong>处理被多次定义的强符号和弱符号：</p>
<ul>
<li><p>不允许强符号被多次定义，即不同的目标文件中不能有同名的强符号；如果有多个强符号，那么链接器会报符号重复定义错误。</p>
</li>
<li><p>如果一个符号在某个目标文件中是强符号，在其他文件中是弱符号，那么选择强符号。</p>
</li>
<li><p>如果一个符号在所有的目标文件中都是弱符号，那么选择其中占用空间最大的一个。</p>
</li>
</ul>
<p>例如目标文件  a.o  定义全局变量  a  为  int  类型，占用 4 个字节，目标文件  b.o  定义  a  为  double  类型，占用 8 个字节，那么被链接后，符号  a  占用 8 个字节，但是自己进行测试的时候，似乎编译器是选择弱符号自己所在文件中的类型，而且<strong>同一个源文件中不允许定义名称相同但是数据类型不同的全局变量</strong>。例如，</p>
<details class="folding-tag" blue><summary> 点击查看实例 </summary>
              <div class='content'>
              <div class="tabs" id="tabname5"><ul class="nav-tabs"><li class="tab active"><a href="#tabname5-1">main.c</a></li><li class="tab"><a href="#tabname5-2">fun1.c</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname5-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">double</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    a = <span class="number">0.3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %f, sizeof(a)=%ld\n&quot;</span>, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname5-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1 a=%d, sizeof(a)=%ld\n&quot;</span>, a, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall    # 编译程序 </span><br><span class="line">./a.out          # 执行可执行程序</span><br></pre></td></tr></table></figure><p>会看到终端有如下信息输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun1 a=20, sizeof(a)=4</span><br><span class="line">a = 0.300000, sizeof(a)=8</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<p>【注意】在  GCC  中，可以通过 <strong>attribute</strong>((weak)) 来强制定义任何一个符号为弱符号。但是 <strong>attribute</strong>((weak)) 只对链接器有效，对编译器不起作用，编译器不区分强符号和弱符号，只要在一个源文件中定义两个相同的符号，不管它们是强是弱，都会报重复定义错误。</p>
<h3 id="4-3-有什么用？"><a href="#4-3-有什么用？" class="headerlink" title="4.3 有什么用？"></a><font size=3>4.3 有什么用？</font></h3><p>我们在开发库时，可以将某些符号定义为弱符号，这样就能够被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的函数，增加了很大的灵活性。</p>
<ul>
<li>强符号覆盖弱符号</li>
</ul>
<div class="tabs" id="tabname6"><ul class="nav-tabs"><li class="tab active"><a href="#tabname6-1">main.c</a></li><li class="tab"><a href="#tabname6-2">fun1.c</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname6-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">__attribute__((weak)) <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname6-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1 a=%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>

<p>在终端执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall    # 编译程序 </span><br><span class="line">./a.out          # 执行可执行程序</span><br></pre></td></tr></table></figure>

<p>会看到终端有如下信息输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun1 a=10</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure>

<p>可以看到，强符号覆盖了弱符号，最后输出的 a 的值都是 10 。</p>
<h3 id="4-4-一个坑"><a href="#4-4-一个坑" class="headerlink" title="4.4 一个坑"></a><font size=3>4.4 一个坑</font></h3><p>按理来说，强弱符号在链接过程中，强符号一定会取代弱符号，但是，事实并非如此我们创建几个文件用来测试：<a target="_blank" rel="noopener" href="https://gitee.com/sumumm/imx6ull-app-demo/tree/master/LV01_GCC_COMPILE/04_symbol">LV01_GCC_COMPILE&#x2F;04_symbol · 苏木&#x2F;imx6ull-app-demo - 码云 - 开源中国</a></p>
<p>我们这里写一个makefile来做不同的编译流程，来看一下坑在哪里：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: demo1 demo2 demo3 demo4</span></span><br><span class="line"><span class="comment"># 第(1)种情况：直接全部编译，main.c strong_symbol.c weak_symbol.c</span></span><br><span class="line"><span class="section">demo1:</span></span><br><span class="line">	gcc -g -o demo1.out main.c strong_symbol.c weak_symbol.c -Wall</span><br><span class="line">	rm -rf *.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第(2)种情况：直接全部编译，main.c strong_symbol.c weak_symbol.c</span></span><br><span class="line"><span class="section">demo2:</span></span><br><span class="line">	gcc -g -o demo2.out main.c weak_symbol.c strong_symbol.c -Wall</span><br><span class="line">	rm -rf *.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第(3)种情况：strong_symbol.c weak_symbol.c编译成.a静态库，打包顺序为 weak_symbol.o strong_symbol.o，然后再和main.c进行链接</span></span><br><span class="line"><span class="section">demo3:</span></span><br><span class="line">	gcc -c weak_symbol.c strong_symbol.c</span><br><span class="line">	ar -r libsymbol_demo3.a weak_symbol.o strong_symbol.o</span><br><span class="line">	gcc -o demo3.out main.c -lsymbol_demo3 -L.</span><br><span class="line">	rm -rf *.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第(4)种情况：strong_symbol.c weak_symbol.c 编译成.a静态库，打包顺序为 strong_symbol.o weak_symbol.o，然后再和main.c进行链接</span></span><br><span class="line"><span class="section">demo4:</span></span><br><span class="line">	gcc -c weak_symbol.c strong_symbol.c</span><br><span class="line">	ar -r libsymbol_demo4.a strong_symbol.o weak_symbol.o</span><br><span class="line">	gcc -o demo4.out main.c -lsymbol_demo4 -L.</span><br><span class="line">	rm -rf *.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	@rm -rf *.a *.so *.out</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们直接看结论：</p>
<img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20250323194559442.png" alt="image-20250323194559442" />

<p>我们直接编译所有文件没问题，但是当我们将两个文件打包成.a库的时候，坑产生了，这里打包的时候，弱符号的.o在前，强符号的.o灾后 的时候，强符号竟然没有替换弱符号，反过来就成功替换了。主要是这个坑，在写库的时候，若是有强弱符号的替换，一定要注意！！！</p>
<h2 id="5-强弱引用"><a href="#5-强弱引用" class="headerlink" title="5. 强弱引用"></a><font size=3>5. 强弱引用</font></h2><p>引用（ Reference ），是指对符号的使用。我们所看到的符号引用，在所有目标文件被链接成可执行文件时，它们的地址都要被找到，如果没有符号定义，链接器就会报符号未定义错误，这种被称为<strong>强引用</strong>（ Strong Reference ）。如果符号有定义，就使用它对应的地址，如果没有定义，也不报错，这种引用就叫<strong>弱引用</strong>（ Weak Reference ），在变量声明或者函数声明前边加上 <strong>attribute</strong>((weak)) 就会使符号变为弱引用。</p>
<p>链接器处理强引用和弱引用的过程几乎是一样的，只是对于未定义的弱引用，链接器不认为它是一个错误，一般默认其为 0 （地址为  0 ），或者是一个特殊的值，以便程序代码能够识别。</p>
<details class="folding-tag" blue><summary> 点击查看实例 </summary>
              <div class='content'>
              <div class="tabs" id="tabname7"><ul class="nav-tabs"><li class="tab active"><a href="#tabname7-1">main.c</a></li><li class="tab"><a href="#tabname7-2">fun1.c</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname7-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">__attribute__((weak)) <span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname7-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1 a=%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div><p>在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall    # 编译程序 </span><br><span class="line">./a.out          # 运行可执行程序</span><br></pre></td></tr></table></figure><p>会看到有如下信息输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun1</span><br><span class="line">&amp;a = (nil)</span><br><span class="line">段错误 (核心已转储)</span><br></pre></td></tr></table></figure><p>在程序，变量 a 是没有进行定义的，直接使用了 extern 来进行声明，当有 __attribute__((weak)) 时表示 a 为弱符号，这个时候再引用 a 的时候就是弱引用了，所以即便没有定义，编译也不会报错，但是程序执行一部分后，需要使用 a 的值得时候，就开始报错了。这是因为 a 的地址是 0 ，这个地址是禁止被访问的。</p><p>若是不想让它报错，可以加一个判断即可，主函数可修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">__attribute__((weak)) <span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p\n&quot;</span>, &amp;a);</span><br><span class="line">    <span class="keyword">if</span>(&amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a is undefined!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<p>弱引用和强引用非常利于程序的模块化开发，我们可以将程序的扩展模块定义为弱引用，当我们将扩展模块和程序链接在一起时，程序就可以正常使用；如果我们去掉了某些模块，那么程序也可以正常链接，只是缺少了某些功能，这使得程序的功能更加容易裁剪和组合。</p>
<h1 id="五、头文件"><a href="#五、头文件" class="headerlink" title="五、头文件"></a><font size=3>五、头文件</font></h1><p>我们写程序的时候，会加上 #include &lt;stdio.h&gt; 这样的头文件， C 语言中 .h 结尾的文件叫做头文件。 .c 和 .h 文件都是源文件，除了后缀不一样便于区分外和管理外，其他的都是相同的。</p>
<p>在 .c 中编写的代码同样也可以写在 .h 中，包括函数定义、变量定义、预处理等。但是 .h  和  .c  承担的角色不一样： .c  文件主要负责实现，也就是定义函数和变量； .h  文件主要负责声明（包括变量声明和函数声明）、宏定义、类型定义等。这些不是 C 语法规定的内容，而是约定成俗的规范，或者说是长期形成的事实标准。</p>
<p>在实际开发中，我们会将函数、变量等的声明放在 .h 文件中，以便于其他程序调用。这样做有什么好处呢？源文件通过编译可以生成目标文件（例如  GCC  下的  .o  和  Visual Studio  下的  .obj ），或者打包成静态库，只要向用户提供头文件，用户就可以将这些模块链接到自己的程序中。这样既可以保护版权，也便于发布和使用。</p>
<h2 id="1-C-语言标准库"><a href="#1-C-语言标准库" class="headerlink" title="1. C 语言标准库"></a><font size=3>1. C 语言标准库</font></h2><p>在 C 语言编程的时候，我们一般是看不到自带函数的具体实现的，例如 printf 函数，我们即便是跳转到定义，也只能看到一个函数生命罢了。这是因为 C 语言允许将多个相关的目标文件打包成一个静态链接库（ Static Link Library ），例如  Linux  下的  .a  文件和  Windows  下的  .lib 文件。 C 语言在发布的时候已经将标准库打包到了静态库，并提供了相应的头文件，例如  stdio.h 、 stdlib.h 、 string.h  等。</p>
<p> Linux  一般将静态库和头文件放在 &#x2F;lib 和 &#x2F;user&#x2F;lib 目录下， C 语言标准库的名字是 libc.a 。  Windows  下，标准库由  IDE  携带，像  Visual Studio ，在安装目录下的 \VC\include 文件夹中会看到很多头文件，包括常用的  stdio.h 、 stdlib.h  等,在 \VC\lib 文件夹中有很多  .lib  文件，这就是链接器要用到的静态库。这里有两个网站，里边对 C 语言的标准库有一些很详细的说明，甚至还有一些函数的使用例子可以参考：</p>
<table>
    <tr>
        <td align="center" width=200>C library</td>
        <td align="left"><a href="http://www.cplusplus.com/reference/clibrary/" target="_blank">http://www.cplusplus.com/reference/clibrary/  <i class="fa fa-external-link-alt"></i> </a></td>  
    </tr>
    <tr>
        <td align="center" width=200>C Standard Library header files</td>
        <td align="left"><a href="https://en.cppreference.com/w/c/header" target="_blank">https://en.cppreference.com/w/c/header  <i class="fa fa-external-link-alt"></i> </a></td>  
    </tr>
</table>


<h2 id="2-自定义头文件"><a href="#2-自定义头文件" class="headerlink" title="2. 自定义头文件"></a><font size=3>2. 自定义头文件</font></h2><p>一般来说我们自己实现了某些模块的功能，我们就可以自己来写相应的头文件，便于自己的调用。根据大家约定俗成的规范，自定义的头文件一般可以包含如下内容：</p>
<ul>
<li>声明函数，但不可以定义函数。</li>
<li>声明变量，但不可以定义变量。</li>
<li>定义宏，包括带参的宏和不带参的宏。</li>
<li>结构体的定义、自定义数据类型一般也放在头文件中。</li>
</ul>
<p>【注意】在头文件声明函数的时候不用像声明变量一样加上 extern ,即便不加也不会造成混乱，为了简便，往往是不用加的。</p>
<details class="folding-tag" blue><summary> 点击查看实例 </summary>
              <div class='content'>
              <p>【说明】引入自定义头文件，一般格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filename.h&quot;</span></span></span><br></pre></td></tr></table></figure><div class="tabs" id="tabname8"><ul class="nav-tabs"><li class="tab active"><a href="#tabname8-1">main.c</a></li><li class="tab"><a href="#tabname8-2">fun1.c</a></li><li class="tab"><a href="#tabname8-3">fun1.h</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname8-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname8-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1 a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname8-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div></div></div><p>在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall    # 编译程序 </span><br><span class="line">./a.out          # 运行可执行程序</span><br></pre></td></tr></table></figure><p>会看到有如下信息输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun1 a = 100</span><br><span class="line">a = 100</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<p>【注意】其实习惯上，在 .h 文件中对函数进行声明，也可以不用添加 extern 关键字（具体原因还没有追究过）。</p>
<h2 id="3-头文件路径"><a href="#3-头文件路径" class="headerlink" title="3. 头文件路径"></a><font size=3>3. 头文件路径</font></h2><p>头文件在被包含的时候有两种格式，一种使用 &lt;&gt; ，另一种使用 “ “ ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filename.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;filename.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>两者区别如下：</p>
<table>
    <tr><td align="center" width=150px>&lt;   &gt;</td><td align="left">编译器会到系统路径（C语言标准静态链接库所在路径，Linux中静态库和头文件一般在/lib和/user/lib目录）下查找头文件。</td></tr>
    <tr><td align="center" width=150px>" "</td><td align="left">编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。 </td></tr>
</table>


<p>也就是说，使用双引号比使用尖括号多了一个查找路径，它的功能更为强大，所以完全可以使用双引号来包含标准头文件。</p>
<p>引入头文件时可以使用绝对路径，也可以使用相对路径。当使用相对路径的方式引入头文件时，如果使用 &lt; &gt; ，那么相对的就是系统路径，也就是说，编译器会直接在这些系统路径下查找头文件；如果使用 “ “ ，那么首先相对的是当前路径，然后相对的才是系统路径，而使用绝对路径的方式引入头文件时， &lt; &gt; 和 “ “ 没有任何区别，因为头文件路径已经固定了（从根目录开始查找），不需要相对任何路径。</p>
<p>总起来说，相对路径要有相对的目标，这个目标可以是当前路径，也可以是系统路径， &lt; &gt; 和 “ “ 决定了到底相对哪个目标。一般来说，自己编写的头文件在引用时最好使用相对路径，这样即便工程进行了移动，文件路径也不会出现问题。</p>
<h2 id="4-重复引入"><a href="#4-重复引入" class="headerlink" title="4. 重复引入"></a><font size=3>4. 重复引入</font></h2><p>头文件包含命令  #include  与直接复制粘贴头文件内容的效果是一样的，预处理器会读取头文件的内容，然后将文件内容插入到  #include  命令所在的位置。如果被包含的头文件中还包含了其他的头文件，预处理器会继续将它们也包含进来；这个过程会一直持续下去，直到不再包含任何头文件。</p>
<h3 id="4-1-有什么问题？"><a href="#4-1-有什么问题？" class="headerlink" title="4.1 有什么问题？"></a><font size=3>4.1 有什么问题？</font></h3><p>不懂就问，文件重复引入的话会有什么问题呢，为什么要关心这个问题？接下来我们看一个实例。</p>
<details class="folding-tag" blue><summary> 点击查看实例 </summary>
              <div class='content'>
              <div class="tabs" id="tabname9"><ul class="nav-tabs"><li class="tab active"><a href="#tabname9-1">main.c</a></li><li class="tab"><a href="#tabname9-2">fun1.c</a></li><li class="tab"><a href="#tabname9-3">fun1.h</a></li><li class="tab"><a href="#tabname9-4">fun2.h</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname9-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main:a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname9-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun1.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1:a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname9-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun2.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname9-4"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure></div></div></div><p>在终端命令行执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c -o main.i</span><br><span class="line">vim main.i</span><br></pre></td></tr></table></figure><img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419220121990.png" alt="image-20220419220121990" style="zoom:50%;" /><p>会发现，变量 a 在预处理后，出现了两次定义。然后我们全部编译链接一下，让它生成可执行程序，在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall # 编译程序</span><br></pre></td></tr></table></figure><p>这个时候我们就会发现，编译似乎并没有报错，甚至于还可以正常执行，个中缘由嘛想一下是为啥嘞？前边提到了弱符号，未赋值的全局变量属于弱符号，它在程序中并不会报错，根据处理规则，会选择其中的一个，但若是提前初始化了，就会导致出现两个强符号，这在 GCC 中是不被允许的。接下来我们可以修改 fun2.h 中 a 的定义，我们直接进行赋值，然后再进行编译，会看到有如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In file included from main.c:3:0:</span><br><span class="line">fun2.h:3:5: error: redefinition of ‘a’</span><br><span class="line"> int a = 10;</span><br><span class="line">     ^</span><br><span class="line">In file included from fun1.h:3:0,</span><br><span class="line">                 from main.c:2:</span><br><span class="line">fun2.h:3:5: note: previous definition of ‘a’ was here</span><br><span class="line"> int a = 10;</span><br><span class="line">     ^</span><br></pre></td></tr></table></figure><p>这是直接报了一个错误，是说 a 重复定义了。</p>
              </div>
            </details>

<p>通过上述例子，我们会发现重复引入头文件的话，头文件中的一些变量也会被多次引入。更不必说 stdio.h  这种标准库头文件中除了有函数声明，还有宏定义、类型定义、结构体定义等，多次引入的话它们都会出现很多次次，如果不做任何处理，不仅可能会出现重复定义错误，而且不符合编程规范。</p>
<h3 id="4-2-如何解决？"><a href="#4-2-如何解决？" class="headerlink" title="4.2 如何解决？"></a><font size=3>4.2 如何解决？</font></h3><p>上边我们看到了头文件重复包含导致的问题，但是我们会发现，为什么 stdio.h 文件也被包含了很多次，但是却没有报错呢，并且里边的内容似乎也仅仅只被包含了一次而已？这是因为标准库头文件使用了宏保护来放置重复引入头文件，一般格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FILENAME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FILENAME_H</span></span><br><span class="line"><span class="comment">/* 需要引入的头文件 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>第一次包含头文件，会定义宏  _FILENAME_H ，并执行”需要引入的头文件”部分的代码；第二次包含时因为已经定义了宏 _FILENAME_H ，不会重复执行”需要引入的头文件”部分的代码。所以头文件只在第一次包含时起作用，再次包含无效。</p>
<p>所以上边的例子可以做一个修改。</p>
<details class="folding-tag" blue><summary> 点击查看实例 </summary>
              <div class='content'>
              <div class="tabs" id="tabname10"><ul class="nav-tabs"><li class="tab active"><a href="#tabname10-1">main.c</a></li><li class="tab"><a href="#tabname10-2">fun1.c</a></li><li class="tab"><a href="#tabname10-3">fun1.h</a></li><li class="tab"><a href="#tabname10-4">fun2.h</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tabname10-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main:a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname10-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun1.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fun1:a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname10-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FUN1_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FUN1_H</span></span><br><span class="line"><span class="comment">/* 需要引入的头文件 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun2.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tabname10-4"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _FUN2_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FUN2_H</span></span><br><span class="line"><span class="comment">/* 需要引入的头文件 */</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div></div></div><p>在终端命令行执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c -o main.i</span><br><span class="line">vim main.i</span><br></pre></td></tr></table></figure><img data-src="https://fanhua-picture.oss-cn-hangzhou.aliyuncs.com/01%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/01HQ%E8%AF%BE%E7%A8%8B%E4%BD%93%E7%B3%BB/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/LV01-08-C%E8%AF%AD%E8%A8%80-%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B/img/image-20220419221732388.png" alt="image-20220419221732388" style="zoom:50%;" /><p>从图中可以推断出，文件只被包含了一次。然后我们全部编译链接一下，让它生成可执行程序，在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -Wall # 编译程序</span><br></pre></td></tr></table></figure><p>这个时候我们就会发现，并没有报错，这是因为它依然是弱符号，但是至少 main.i 中没有出现重复定义的 a 了。那要是变为强符号呢？我们对 fun2.h 中的 a 进行赋值，然后再编译链接，会看到如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccLQGYqr.o:(.data+0x0):  a 被多次定义</span><br><span class="line">/tmp/cctZ4oU9.o:(.data+0x0)：第一次在此定义</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>虽然没有报 error ，但是编译还是无法通过，所以呢，即便是只引入一次，但是依然在 GCC 中不被允许。</p>
              </div>
            </details>

<p>从上边的例子中可以看出，宏保护可以有效防止文件的重复引入，但是对于定义在头文件中的变量依然会有问题，所以最好的方法当然就是规范编程习惯啦，将变量定义到 .c 文件中去， .h 文件只负责声明就没得问题啦。</p>
<h1 id="六、-extern-与-h"><a href="#六、-extern-与-h" class="headerlink" title="六、 extern 与 .h "></a><font size=3>六、 extern 与 .h </font></h1><p>从上边可以看出， extern 与 .h 头文件有些功能是很类似的，那他们有什么不同嘛？既然用  #include 可以包含其他头文件中变量、函数的声明，为什么还要  extern  关键字嘞？本部分笔记主要参考了这篇文章</p>
<h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件"></a><font size=3>1. 头文件</font></h2><p>不管是 C 还是 C++ ，我们要是把函数，变量或者结构体，类啥的放在 .c 或者 .cpp 文件里。然后编译成 lib 、 dll 、 obj 、 .o 等等，然后其他人用的时候，最基本的就是直接 gcc hisfile.c ourfile.o  等等。但对于其他开发者来说，他们怎么知道我们的 lib 、 dll 、 obj 或者 .o 里面到底有什么东西？这个时候要看头文件啦。头文件就需要有对用户的说明，函数，参数，各种各样的接口的说明等。既然是说明，那么头文件里面放的自然就是关于函数，变量，类的”声明”(对函数来说，也叫函数原型)了。</p>
<p>我们可以将头文件后缀改为 .text ，在引用该头文件的地方用  #include “xxx.txt” ，然后再去编译链接程序，会发现，依然可以全部通过，这就说明，其实头文件仅仅是通过被包含将自己里边的内容插入到被需要的地方去，没有其他的作用。</p>
<p>还记得上边重复引入的问题吧，在头文件中定义的变量即便我们用上了宏保护，但是依然在生成可执行文件的过程中出现了错误，严格来讲应该是在链接的过程中会报重复定义的错误。这是因为多个  c  文件包含这个头文件时，因为宏名有效范围仅限于本 c 源文件，所以在这多个  c  文件编译时是不会出错的，但在链接时就会报错：就像上边一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp/ccLQGYqr.o:(.data+0x0):  a 被多次定义</span><br><span class="line">/tmp/cctZ4oU9.o:(.data+0x0)：第一次在此定义</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<h2 id="2-extern"><a href="#2-extern" class="headerlink" title="2. extern "></a><font size=3>2. extern </font></h2><p>在定义变量的时候，这个 extern 可以被省略(定义时，默认均省略)；在声明变量的时候，这个 extern 必须添加在变量前，所以有时会让我们搞不清楚到底是声明还是定义。或者说，变量前有 extern 不一定就是声明，而变量前无 extern 就只能是定义。注意，定义要是为变量分配内存空间的；而声明不需要。</p>
<ul>
<li>变量</li>
</ul>
<p>对于变量来说，有如下几种形式，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;     <span class="comment">/* 声明一个全局变量 a */</span></span><br><span class="line"><span class="type">int</span> a;            <span class="comment">/* 定义一个全局变量 a */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a =<span class="number">0</span> ; <span class="comment">/* 定义一个全局变量 a 并赋初值 */</span></span><br><span class="line"><span class="type">int</span> a =<span class="number">0</span>;         <span class="comment">/* 定义一个全局变量 a, 并赋初值 */</span></span><br></pre></td></tr></table></figure>

<p>其中， int a； 、 extern int a&#x3D;0； 还有 int a&#x3D;0; 都<strong>只能出现一次</strong>，而那个 extern int a; <strong>可以出现很多次</strong>。我们需要引用一个全局变量的时候，就必须要声明 extern int a;  这时候 extern 不能省略，若是省略了，就变成 int a; 这是一个定义，不是声明。注意， extern int a;  中类型  int  可省略，即  extern a;  但其他类型则不能省略。</p>
<ul>
<li>函数</li>
</ul>
<p>对于函数也一样，也是定义和声明，定义的时候用 extern ，说明这个函数是可以被外部引用的，声明的时候用 extern 说明这是一个声明。 但由于函数的定义和声明是有区别的，定义函数要有函数体，声明函数没有函数体(还有以分号结尾)，所以函数定义和声明时都可以将 extern 省略掉，有没有 extern 其他文件也都是知道这个函数是在其他地方定义的，所以不加 extern 也行，两者很容易区分，所以省略了 extern 也不会有问题。</p>
<ul>
<li>总而言之</li>
</ul>
<blockquote>
<p>对变量，如果想在本源文件A中使用另一个源文件B中的变量，方法有两种：</p>
<p>(1)在A文件中必须用extern声明在B文件中定义的变量(当然是全局变量)；</p>
<p>(2)在A文件中添加B文件对应的头文件，这个头文件需要包含B文件中的变量声明，即在这个头文件中必须用extern声明该变量，否则，该变量又会被定义一次。</p>
<p>对函数，如果想在本源文件A中使用另一个源文件B的函数，方法也有两种：</p>
<p>(1)在A文件中用extern声明在B文件中定义的函数(其实也可省略extern，只需在A文件中出现B文件定义函数原型即可，这样似乎也不会有什么问题)；</p>
<p>(2)在A文件中添加B文件对应的头文件，当然这个头文件包含B文件中的函数原型，在头文件中函数可以不用加extern。</p>
</blockquote>
<h2 id="3-两者联系"><a href="#3-两者联系" class="headerlink" title="3. 两者联系"></a><font size=3>3. 两者联系</font></h2><p>上边看完，有两个问题：</p>
<p>（1）用 #include 可以包含其他头文件中变量、函数的声明，为什么还要 extern 关键字？</p>
<p>（2）如果想引用一个全局变量或函数 a ，只要直接在源文件中包含 #include  ( xxx.h 包含了 a 的声明)不就可以了么，为什么还要用 extern 呢？</p>
<p>如果一个文件 A 要大量引用另一个文件 B 中定义的变量或函数，则使用头文件效率更高，程序结构也更规范。其他文件(例如文件名 C 、 D 等)要引用文件名 B 中定义的变量或函数，则只需用 #include 包含文件 B 对应的头文件(要注意这个头文件只有对变量或函数的声明，绝不能有定义)即可。</p>
<p>很久很久以前，有一个编译器😁，它只认识 .c (或 .cpp )文件，而不知道 .h 是什么。那时的人们写了很多的 .c (或 .cpp )文件，渐渐地，人们发现在很多 .c (或 .cpp )文件中的声明变量或函数原型是相同的，但他们却不得不一个字一个字地重复地将这些内容敲入每个 .c (或 .cpp )文件。但更为恐怖的是，当其中一个声明有变更时，就需要检查所有的 .c (或 .cpp )文件，并修改其中的声明，额，这就太恐怖了😇。</p>
<p>后来终于，有人或许是一些人再不能忍受这样的折磨，他们将重复的部分提取出来，放在一个新文件里，然后在需要的 .c (或 .cpp )文件中敲入 #include XXX 这样的语句。这样即使某个声明发生了变更，也再不需要到处寻找与修改了😃.</p>
<p>这个新文件，经常被放在 .c (或 .cpp )文件的头部，所以就给它起名叫做<strong>头文件</strong>，扩展名是 .h 。从此，编译器（其实是其中预处理器）就知道世上除了 .c (或 .cpp )文件，还有 .h 文件，以及一个叫做 #include 命令。</p>

    </div>

    
    
    

    <footer class="post-footer">




    <div>
        
            <div style="text-align:center;color: #ccc;font-size:14px;">
            ----------本文结束
            <i class="fas fa-fan fa-spin" style="color: #FF1493; font-size: 1rem"></i>
            感谢您的阅读----------
            </div>
        
    </div>





  
  <div class="my_post_copyright"> 
    <p><span>文章标题:</span><a href="/post/e57fdc7f.html">LV01-08-C语言-多文件</a></p>
    <p><span>文章作者:</span><a href="/" title="欢迎访问 《苏木》 的学习笔记">苏木</a></p>
    <p><span>发布时间:</span>2022年01月18日 - 07:20</p>
    <p><span>最后更新:</span>2025年06月14日 - 00:25</p>
    <p><span>原始链接:</span><a href="/post/e57fdc7f.html" title="LV01-08-C语言-多文件">https://sumumm.github.io/post/e57fdc7f.html</a></p>
    <p><span>许可协议:</span><i class="fab fa-creative-commons"></i> <a rel="license" href= "https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
  </div>
  


          <div class="post-tags">
              <a href="/tags/LV01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> LV01-C语言基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/post/dcb00192.html" rel="prev" title="LV02-01-Linux-01-软件包管理">
                  <i class="fa fa-angle-left"></i> LV02-01-Linux-01-软件包管理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/post/203e48a8.html" rel="next" title="LV01-07-C语言-函数">
                  LV01-07-C语言-函数 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2017 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">苏木</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">3.7m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">225:26</span>
  </span>
</div>




    <span id="sitetime"></span>
    <script defer language=javascript>
        function siteTime()
        {
            window.setTimeout("siteTime()", 1000);
            var seconds = 1000;
            var minutes = seconds * 60;
            var hours = minutes * 60;
            var days = hours * 24;
            var years = days * 365;
            var today = new Date();
            var todayYear = today.getFullYear();
            var todayMonth = today.getMonth()+1;
            var todayDate = today.getDate();
            var todayHour = today.getHours();
            var todayMinute = today.getMinutes();
            var todaySecond = today.getSeconds();
            /*==================================================
            Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
            year        - 作为date对象的年份，为4位年份值
            month       - 0-11之间的整数，做为date对象的月份
            day         - 1-31之间的整数，做为date对象的天数
            hours       - 0(午夜24点)-23之间的整数，做为date对象的小时数
            minutes     - 0-59之间的整数，做为date对象的分钟数
            seconds     - 0-59之间的整数，做为date对象的秒数
            microseconds - 0-999之间的整数，做为date对象的毫秒数
            ==================================================*/
            var t1 = Date.UTC(2017, 
                              5, 
                              19, 
                              0, 
                              0, 
                              0); //北京时间
            var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
            var diff = t2-t1;
            var diffYears = Math.floor(diff/years);
            var diffDays = Math.floor((diff/days)-diffYears*365);
            var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
            var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
            var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
            document.getElementById("sitetime").innerHTML="已在这里 "+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
        }
        siteTime();
    </script>



    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.28/fancybox/fancybox.umd.js" integrity="sha256-ytMJGN3toR+a84u7g7NuHm91VIR06Q41kMWDr2pq7Zo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


 
        <div id="click-show-text"
            data-mobile = false
            data-text = 富强,民主,文明,和谐,自由,平等,公正,法制,爱国,敬业,诚信,友善
            data-fontsize = 15px
            data-random= false>
        </div>
       

      
        <script async src=https://cdn.jsdelivr.net/npm/hexo-next-mouse-effect@latest/click/showText.js></script>
      

      
    




    <script async src="/js/fancybox_param.js"></script>





<!-- APlayer本体 -->



</body>
</html>
